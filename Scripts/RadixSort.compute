#pragma kernel prefixSum
#pragma kernel prefixFixup
#pragma kernel split_prep
#pragma kernel split_scatter
#pragma kernel copyParticles
#pragma kernel clearBuffer32
#pragma kernel clearBuffer64

#define SCAN_BLOCKSIZE 512

// Particle struct definition (must match Particles.compute)
struct Particle
{
    float3 position;    // 3-component position vector
    float3 velocity;    // float face velocities
    uint layer;         // Layer units
    uint mortonCode;    // Morton code for spatial indexing
};

RWStructuredBuffer<uint> input;
RWStructuredBuffer<uint> output;
RWStructuredBuffer<uint> aux;
uint len;
uint zeroff;

RWStructuredBuffer<Particle> inputParticles;
RWStructuredBuffer<Particle> outputParticles;
uint count;
uint bit;
RWStructuredBuffer<uint> e;
RWStructuredBuffer<uint> f;

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixFixup(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint start = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint block_sum = aux[blockIdx];

    if (start < len)                    input[start] += block_sum;
    if (start + SCAN_BLOCKSIZE < len)   input[start + SCAN_BLOCKSIZE] += block_sum;
}

groupshared uint scan_array[SCAN_BLOCKSIZE * 2];

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixSum(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint t1 = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint t2 = t1 + SCAN_BLOCKSIZE;

    scan_array[threadIdx] = (t1 < len) ? input[t1] : 0;
    scan_array[threadIdx + SCAN_BLOCKSIZE] = (t2 < len) ? input[t2] : 0;
    GroupMemoryBarrierWithGroupSync();

    for (uint s1 = 1; s1 <= SCAN_BLOCKSIZE; s1 <<= 1)
    {
        uint index = (threadIdx + 1) * s1 * 2 - 1;
        if (index < 2 * SCAN_BLOCKSIZE)
            scan_array[index] += scan_array[index - s1];
        GroupMemoryBarrierWithGroupSync();
    }

    for (uint s2 = SCAN_BLOCKSIZE >> 1; s2 > 0; s2 >>= 1)
    {
        uint index = (threadIdx + 1) * s2 * 2 - 1;
        if (index + s2 < 2 * SCAN_BLOCKSIZE)
            scan_array[index + s2] += scan_array[index];
        GroupMemoryBarrierWithGroupSync();
    }
    GroupMemoryBarrierWithGroupSync();

    if (t1 + zeroff < len)    output[t1 + zeroff] = scan_array[threadIdx];
    if (t2 + zeroff < len)    output[t2 + zeroff] = (threadIdx == SCAN_BLOCKSIZE - 1 && zeroff) ? 0 : scan_array[threadIdx + SCAN_BLOCKSIZE];
    if (threadIdx == 0)
    {
        if (zeroff) output[0] = 0;
        aux[blockIdx] = scan_array[2 * SCAN_BLOCKSIZE - 1];
    }
}

[numthreads(512, 1, 1)]
void split_prep(uint3 id : SV_DispatchThreadID)
{
    uint tid = id.x;
    if (tid >= count) {
        return;
    }

    e[tid] = (inputParticles[tid].mortonCode & (1U << bit)) == 0;
}

[numthreads(512, 1, 1)]
void split_scatter(uint3 id : SV_DispatchThreadID)
{
    uint tid = id.x;
    if (tid >= count) {
        return;
    }

    uint totalFalses = f[count - 1] + e[count - 1];

    bool isBitSet = (inputParticles[tid].mortonCode & (1U << bit)) != 0;

    uint destinationIndex;
    if (isBitSet) {
        destinationIndex = totalFalses + (tid - f[tid]);
    }
    else {
        destinationIndex = f[tid];
    }


    outputParticles[destinationIndex] = inputParticles[tid];
}

[numthreads(512, 1, 1)]
void copyParticles(uint3 id : SV_DispatchThreadID)
{
    uint tid = id.x;
    if (tid >= count) return;
    outputParticles[tid] = inputParticles[tid];
}

[numthreads(512, 1, 1)]
void clearBuffer32(uint3 id : SV_DispatchThreadID)
{
    uint tid = id.x;
    if (tid < count) {
        output[tid] = 0;
    }
}

[numthreads(512, 1, 1)]
void clearBuffer64(uint3 id : SV_DispatchThreadID)
{
    uint tid = id.x;
    if (tid < count) {
        Particle emptyParticle;
        emptyParticle.position = float3(0, 0, 0);
        emptyParticle.velocity = float3(0, 0, 0);
        emptyParticle.layer = 0;
        emptyParticle.mortonCode = 0;
        outputParticles[tid] = emptyParticle;
    }
}