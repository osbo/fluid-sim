#pragma kernel CreateLeaves
#pragma kernel ProcessNodes
#pragma kernel pullVelocities
#pragma kernel copyFaceVelocities

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Neighbors are stored as a flat buffer of 24 uints per node:
// [left4, right4, bottom4, top4, front4, back4]

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes
RWStructuredBuffer<Node> tempNodesBuffer;               // output: per-node gathered face deltas
RWStructuredBuffer<uint> neighborsBuffer;               // output: neighbor indices per node (numNodes * 24)

uint numUniqueNodes;                              // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer

// Morton helpers: interleave/deinterleave 3D (10 bits per axis)
uint3 deinterleave(uint m)
{
    uint x = 0, y = 0, z = 0;
    for (uint i = 0; i < 10; i++)
    {
        x |= ((m >> (3 * i + 0)) & 1) << i;
        y |= ((m >> (3 * i + 1)) & 1) << i;
        z |= ((m >> (3 * i + 2)) & 1) << i;
    }
    return uint3(x, y, z);
}

uint interleave(uint3 p)
{
    uint m = 0;
    for (uint i = 0; i < 10; i++)
    {
        m |= ((p.x & (1u << i)) << (2 * i + 0));
        m |= ((p.y & (1u << i)) << (2 * i + 1));
        m |= ((p.z & (1u << i)) << (2 * i + 2));
    }
    return m;
}

// Helper: given direction d, return neighbor's opposing face value
float selectOpposingFace(faceVelocities v, int d)
{
    // d: 0=left,1=right,2=bottom,3=top,4=front,5=back
    if (d == 0) return v.right;
    if (d == 1) return v.left;
    if (d == 2) return v.top;
    if (d == 3) return v.bottom;
    if (d == 4) return v.back;
    return v.front; // d == 5
}

// Helper: subtract value from the correct face on outNode for direction d
void subtractToFace(inout Node outNode, int d, float value)
{
    if (d == 0) outNode.velocities.left -= value;
    else if (d == 1) outNode.velocities.right -= value;
    else if (d == 2) outNode.velocities.bottom -= value;
    else if (d == 3) outNode.velocities.top -= value;
    else if (d == 4) outNode.velocities.front -= value;
    else outNode.velocities.back -= value; // d == 5
}

// Helper: face offset inside 24-wide neighbors block
uint faceOffset(int d)
{
    // left=0..3, right=4..7, bottom=8..11, top=12..15, front=16..19, back=20..23
    if (d == 0) return 0u;
    if (d == 1) return 4u;
    if (d == 2) return 8u;
    if (d == 3) return 12u;
    if (d == 4) return 16u;
    return 20u; // d == 5
}

// Lower-bound search: first index with mortonCode >= target
// left is inclusive, right is exclusive
uint lowerBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound; // exclusive
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode < target)
        {
            left = mid + 1u;
        }
        else
        {
            right = mid;
        }
    }
    return left;
}

// Upper-bound search: last index with mortonCode <= target
// left_bound is inclusive, right_bound is exclusive
uint upperBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound;
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode > target)
        {
            right = mid;
        }
        else
        {
            left = mid + 1u;
        }
    }
    return left - 1u; // return last position where code <= target
}

[numthreads(512, 1, 1)]
void CreateLeaves(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;
    
    // Get the index into sorted arrays for this unique morton code
    uint rangeStart = uniqueIndices[threadIndex];
    
    // Find how many particles share this morton code
    uint rangeEnd = threadIndex + 1 < numNodes ? uniqueIndices[threadIndex + 1] : numParticles;
    
    // Aggregate particle data with weighted average
    float3 weightedPosition = float3(0, 0, 0);
    faceVelocities leafVelocities;
    leafVelocities.left = 1.0;
    leafVelocities.right = 1.0;
    leafVelocities.bottom = 1.0;
    leafVelocities.top = 1.0;
    leafVelocities.front = 1.0;
    leafVelocities.back = 1.0;
    
    float totalWeight = 1.0;
    uint minLayer = 11;
    
    // Process all particles with this morton code
    for (uint i = rangeStart; i < rangeEnd; i++)
    {
        Particle particle = particlesBuffer[i];
        
        // Weight = 8^(particle.layer), but since layer is always 0, weight = 8^0 = 1
        float weight = pow(8.0, (float)particle.layer);
        weightedPosition += particle.position * weight;
        totalWeight += weight;

        // float3 velocity = particle.velocity;
        // if (velocity.x < 0) {
        //     leafVelocities.left += velocity.x * -1;
        // } else {
        //     leafVelocities.right += velocity.x;
        // }
        // if (velocity.y < 0) {
        //     leafVelocities.bottom += velocity.y * -1;
        // } else {
        //     leafVelocities.top += velocity.y;
        // }
        // if (velocity.z < 0) {
        //     leafVelocities.front += velocity.z * -1;
        // } else {
        //     leafVelocities.back += velocity.z;
        // }
        
        // Track minimum layer
        minLayer = min(minLayer, particle.layer);
    }
    
    // Normalize by total weight (center of mass)
    // Safety check: prevent division by zero
    if (totalWeight > 0.0) {
        weightedPosition /= totalWeight;
    }

    uint mortonCode = particlesBuffer[rangeStart].mortonCode;
    
    // Create the node
    Node node;
    node.position = weightedPosition;
    node.velocities = leafVelocities;
    node.layer = minLayer;  // Use the minimum layer found
    node.mortonCode = mortonCode;
    node.active = 1;
    
    // Write outputs
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;

    uint uniqueStart = uniqueIndices[threadIndex];
    uint uniqueEnd = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    uint numNodesInGroup = uniqueEnd - uniqueStart;

    // Safety check: prevent infinite loops
    if (numNodesInGroup <= 1 || uniqueStart >= uniqueEnd || uniqueEnd > numNodes) return;

    bool coarsen = true;
    for (uint i = uniqueStart; i < uniqueEnd; i++)
    {
        Node node = nodesBuffer[i];
        if (node.layer < layer) {
            coarsen = false;
            break;
        }
    }

    if (coarsen)
    // if (0)
    {
        uint baseCode = nodesBuffer[uniqueStart].mortonCode;
        uint shift = layer * 3u;
        uint prefix = baseCode >> shift; // 3b-bit prefix
        uint3 coord = deinterleave(prefix);

        uint gridDim = 1u << (10 - layer);

        int3 deltas[6] = { int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1) };
        // [unroll]
        for (int d = 0; d < 6 && coarsen; d++)
        {
            int nx = (int)coord.x + deltas[d].x;
            int ny = (int)coord.y + deltas[d].y;
            int nz = (int)coord.z + deltas[d].z;

            // Bounds at this layer's grid (disabled for now)
            // if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
            // {
            //     coarsen = false;
            //     break;
            // }

            uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
            uint nPrefix = interleave(ncoord);

            uint lower = nPrefix << shift;
            uint upper = (nPrefix + 1u) << shift; // exclusive

            uint idx_low = lowerBoundMorton(lower, 0, numNodes);

            // this isn't perfect, but it's honestly fast enough. It's bounded to at most 8 iterations, and is robust.
            for (uint j = idx_low; j < numNodes; j++)
            {
                Node node = nodesBuffer[j];
                if (node.mortonCode >= upper)
                {
                    break;
                }
                if (node.layer < layer - 1)
                {
                    coarsen = false;
                    break;
                }
            }
        }
    }

    if (coarsen)
    {
        faceVelocities aggregatedVelocities;
        aggregatedVelocities.left = 0.0;
        aggregatedVelocities.right = 0.0;
        aggregatedVelocities.bottom = 0.0;
        aggregatedVelocities.top = 0.0;
        aggregatedVelocities.front = 0.0;
        aggregatedVelocities.back = 0.0;
        float3 weightedPosition = float3(0, 0, 0);
        float totalWeight = 0.0;
        uint minLayer = 11;

        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            float weight = pow(8.0, (float)node.layer);
            weightedPosition += node.position * weight;
            totalWeight += weight;
            aggregatedVelocities.left += node.velocities.left;
            aggregatedVelocities.right += node.velocities.right;
            aggregatedVelocities.bottom += node.velocities.bottom;
            aggregatedVelocities.top += node.velocities.top;
            aggregatedVelocities.front += node.velocities.front;
            aggregatedVelocities.back += node.velocities.back;
            minLayer = min(minLayer, node.layer);
        }

        // Safety check: prevent division by zero
        if (totalWeight > 0.0) {
            weightedPosition /= totalWeight;
        }

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocities = aggregatedVelocities;
        aggregatedNode.layer = minLayer;
        aggregatedNode.mortonCode = nodesBuffer[uniqueStart].mortonCode;
        aggregatedNode.active = 1;

        nodesBuffer[uniqueStart] = aggregatedNode;

        for (uint i = 1; i < numNodesInGroup; i++)
        {
            nodesBuffer[uniqueStart + i].active = 0;
        }
    } else {
        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            if (node.layer > layer) {
                nodesBuffer[i].layer = layer - 1;
            }
        }
    }
}

// Next step: handle bigger than current layer
// Do multiplier when aggregating based on layer

[numthreads(512, 1, 1)]
void pullVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    faceVelocities selfVel = node.velocities;

    // Initialize output (delta) node with zero face velocities
    Node outNode;
    outNode.position = node.position;
    outNode.layer = node.layer;
    outNode.mortonCode = node.mortonCode;
    outNode.active = node.active;
    outNode.velocities = node.velocities;

    // Initialize neighbors to invalid index (numNodes) for all 24 slots
    uint nbBase = threadIndex * 24;
    for (uint k = 0; k < 24; k++)
    {
        neighborsBuffer[nbBase + k] = numNodes;
    }

    // all face neighbors of this node. It's bounded to 2:1 ratio
    int3 deltas[6] = {int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1)};
    for (int d = 0; d < 6; d++)
    {
        uint shift = node.layer * 3;
        uint prefix = node.mortonCode >> shift;
        uint3 coord = deinterleave(prefix);

        int nx = (int)coord.x + deltas[d].x;
        int ny = (int)coord.y + deltas[d].y;
        int nz = (int)coord.z + deltas[d].z;
        
        // Skip if neighbor is outside the grid bounds for this layer
        uint gridDim = 1u << (10 - node.layer);
        if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
        {
            // Zero the boundary face and transfer its value to the opposite face
            if (d == 0) { // Left boundary: move left to right
                outNode.velocities.right += selfVel.left;
                outNode.velocities.left = 0;
            } else if (d == 1) { // Right boundary: move right to left
                outNode.velocities.left += selfVel.right;
                outNode.velocities.right = 0;
            } else if (d == 2) { // Bottom boundary: move bottom to top
                outNode.velocities.top += selfVel.bottom;
                outNode.velocities.bottom = 0;
            } else if (d == 3) { // Top boundary: move top to bottom
                outNode.velocities.bottom += selfVel.top;
                outNode.velocities.top = 0;
            } else if (d == 4) { // Front boundary: move front to back
                outNode.velocities.back += selfVel.front;
                outNode.velocities.front = 0;
            } else if (d == 5) { // Back boundary: move back to front
                outNode.velocities.front += selfVel.back;
                outNode.velocities.back = 0;
            }
            continue; // Skip this neighbor direction
        }
        
        uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
        uint nPrefix = interleave(ncoord);

        // same-layer neighbor: leq prefix will fall under eq. Layer will be eq.
        // parent neighbor: leq prefix fill fall under less or equal, but layer will be +1
        // child neighbor: search geq for lower and upper bounds. Layer will be -1, operate on all 4 subnodes.

        uint target = nPrefix << shift;
        uint upper = (nPrefix + 1u) << shift; // start of next region

        // Find the last node in this region by finding first node in next region, then subtract 1
        uint idx_next = lowerBoundMorton(upper, 0, numNodes);
        uint idx_leq = (idx_next > 0) ? idx_next - 1u : 0u;

        // Skip if no valid neighbor found
        if (idx_leq >= numNodes) continue;

        Node nNode = nodesBuffer[idx_leq];
        uint idx_leq_mc = nNode.mortonCode;
        uint idx_leq_mc_prefix = idx_leq_mc >> shift;
        uint idx_leq_layer = nNode.layer;

        if (idx_leq_mc_prefix == nPrefix && idx_leq_layer == node.layer)
        {
            // same-layer neighbor
            float opp = selectOpposingFace(nNode.velocities, d);
            subtractToFace(outNode, d, opp);
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else if ((idx_leq_mc >> (shift + 3)) == (nPrefix >> 3) && idx_leq_layer == node.layer + 1)
        {
            // parent neighbor (divide incoming velocity by 4)
            float oppP = selectOpposingFace(nNode.velocities, d) * 0.25;
            subtractToFace(outNode, d, oppP);
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else
        {
            uint idx_target = lowerBoundMorton(target, 0, numNodes); // low child bound
            uint idx_upper = lowerBoundMorton(upper, 0, numNodes); // high child bound
            if (idx_target < idx_upper)
            {
                // child neighbor
                uint nPrefixShifted = nPrefix << 3;
                int subNodesLower[4];
                if (d == 0) { // right face
                    subNodesLower[0] = 1;
                    subNodesLower[1] = 3;
                    subNodesLower[2] = 5;
                    subNodesLower[3] = 7;
                } else if (d == 1) { // left face
                    subNodesLower[0] = 0;
                    subNodesLower[1] = 2;
                    subNodesLower[2] = 4;
                    subNodesLower[3] = 6;
                } else if (d == 2) { // top face
                    subNodesLower[0] = 2;
                    subNodesLower[1] = 3;
                    subNodesLower[2] = 6;
                    subNodesLower[3] = 7;
                } else if (d == 3) { // bottom face
                    subNodesLower[0] = 0;
                    subNodesLower[1] = 1;
                    subNodesLower[2] = 4;
                    subNodesLower[3] = 5;
                } else if (d == 4) { // back face
                    subNodesLower[0] = 4;
                    subNodesLower[1] = 5;
                    subNodesLower[2] = 6;
                    subNodesLower[3] = 7;
                } else if (d == 5) { // front face
                    subNodesLower[0] = 0;
                    subNodesLower[1] = 1;
                    subNodesLower[2] = 2;
                    subNodesLower[3] = 3;
                }

                for (int i = 0; i < 4; i++)
                {
                    uint subPrefix = nPrefixShifted + subNodesLower[i];
                    uint subLower = subPrefix << (shift - 3);
                    uint subUpper = (subPrefix + 1u) << (shift - 3);
                    uint idx_sub = lowerBoundMorton(subLower, idx_target, idx_upper);
                    if (idx_sub < idx_upper)
                    {
                        Node cNode = nodesBuffer[idx_sub];
                        uint idx_sub_mc = cNode.mortonCode;
                        uint idx_sub_mc_prefix = idx_sub_mc >> (shift - 3);
                        uint idx_sub_layer = cNode.layer;
                        if (idx_sub_mc_prefix == subPrefix && idx_sub_layer == node.layer - 1)
                        {
                            float oppC = selectOpposingFace(cNode.velocities, d);
                            subtractToFace(outNode, d, oppC);
                            neighborsBuffer[threadIndex * 24 + faceOffset(d) + i] = idx_sub;
                        }
                    }
                }
            }
        }
    }

    // Write gathered deltas to temp buffer for this node
    tempNodesBuffer[threadIndex] = outNode;
}

[numthreads(512, 1, 1)]
void copyFaceVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    nodesBuffer[threadIndex] = tempNodesBuffer[threadIndex];
}