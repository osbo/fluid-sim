#pragma kernel CreateLeaves
#pragma kernel ProcessNodes

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes

uint numUniqueNodes;                              // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer

// Morton helpers: interleave/deinterleave 3D (10 bits per axis)
uint3 deinterleave(uint m)
{
    uint x = 0, y = 0, z = 0;
    for (uint i = 0; i < 10; i++)
    {
        x |= ((m >> (3 * i + 0)) & 1) << i;
        y |= ((m >> (3 * i + 1)) & 1) << i;
        z |= ((m >> (3 * i + 2)) & 1) << i;
    }
    return uint3(x, y, z);
}

uint interleave(uint3 p)
{
    uint m = 0;
    for (uint i = 0; i < 10; i++)
    {
        m |= ((p.x & (1u << i)) << (2 * i + 0));
        m |= ((p.y & (1u << i)) << (2 * i + 1));
        m |= ((p.z & (1u << i)) << (2 * i + 2));
    }
    return m;
}

// Lower-bound search: first index with mortonCode >= target
uint lowerBoundMorton(uint target)
{
    uint left = 0u;
    uint right = numNodes; // exclusive
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode < target)
        {
            left = mid + 1u;
        }
        else
        {
            right = mid;
        }
    }
    return left;
}

// // Check if 8 subnodes of a neighbor cell (at layer-1) are all at appropriate layers
// bool checkSubnodes(uint nPrefix, uint currentLayer)
// {
//     // 8 binary numbers with 3 bits: 000, 001, 010, 011, 100, 101, 110, 111
//     int subOffsets[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
//     int subCount = 8;
//     uint shiftedPrefix = nPrefix << 3;
    
//     // Check each subnode
//     for (int s = 0; s < subCount; s++)
//     {
//         uint subPrefix = shiftedPrefix + subOffsets[s];
        
//         // Shift the rest of the way left (shift-3) to get lower
//         uint subLower = subPrefix << ((currentLayer-1) * 3);
//         uint subUpper = (subPrefix + 1u) << ((currentLayer-1) * 3);
        
//         // Search for the first node after this target morton code (inclusive)
//         uint subIdx = lowerBoundMorton(subLower);
//         if (subIdx < numNodes)
//         {
//             uint subCode = nodesBuffer[subIdx].mortonCode;
//             if (subCode >= subLower && subCode < subUpper)
//             {
//                 uint subLayer = nodesBuffer[subIdx].layer;
//                 if (subLayer < (currentLayer - 1))
//                 {
//                     return false; // Subnode is too coarse
//                 }
//             }
//         }
//     }
    
//     return true; // All subnodes are appropriate
// }

[numthreads(512, 1, 1)]
void CreateLeaves(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;
    
    // Get the index into sorted arrays for this unique morton code
    uint rangeStart = uniqueIndices[threadIndex];
    
    // Find how many particles share this morton code
    uint rangeEnd = threadIndex + 1 < numNodes ? uniqueIndices[threadIndex + 1] : numParticles;
    
    // Aggregate particle data with weighted average
    float3 weightedPosition = float3(0, 0, 0);
    faceVelocities leafVelocities;
    leafVelocities.left = 0.0;
    leafVelocities.right = 0.0;
    leafVelocities.bottom = 0.0;
    leafVelocities.top = 0.0;
    leafVelocities.front = 0.0;
    leafVelocities.back = 0.0;
    
    float totalWeight = 0.0;
    uint minLayer = 11;
    
    // Process all particles with this morton code
    for (uint i = rangeStart; i < rangeEnd; i++)
    {
        Particle particle = particlesBuffer[i];
        
        // Weight = 8^(particle.layer), but since layer is always 0, weight = 8^0 = 1
        float weight = pow(8.0, (float)particle.layer);
        weightedPosition += particle.position * weight;
        totalWeight += weight;

        float3 velocity = particle.velocity;
        if (velocity.x < 0) {
            leafVelocities.left += velocity.x * -1;
        } else {
            leafVelocities.right += velocity.x;
        }
        if (velocity.y < 0) {
            leafVelocities.bottom += velocity.y * -1;
        } else {
            leafVelocities.top += velocity.y;
        }
        if (velocity.z < 0) {
            leafVelocities.front += velocity.z * -1;
        } else {
            leafVelocities.back += velocity.z;
        }
        
        // Track minimum layer
        minLayer = min(minLayer, particle.layer);
    }
    
    // Normalize by total weight (center of mass)
    // Safety check: prevent division by zero
    if (totalWeight > 0.0) {
        weightedPosition /= totalWeight;
    }

    uint mortonCode = particlesBuffer[rangeStart].mortonCode;
    
    // Create the node
    Node node;
    node.position = weightedPosition;
    node.velocities = leafVelocities;
    node.layer = minLayer;  // Use the minimum layer found
    node.mortonCode = mortonCode;
    node.active = 1;
    
    // Write outputs
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;

    uint uniqueStart = uniqueIndices[threadIndex];
    uint uniqueEnd = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    uint numNodesInGroup = uniqueEnd - uniqueStart;

    // Safety check: prevent infinite loops
    if (numNodesInGroup <= 1 || uniqueStart >= uniqueEnd || uniqueEnd > numNodes) return;

    bool coarsen = true;
    for (uint i = uniqueStart; i < uniqueEnd; i++)
    {
        Node node = nodesBuffer[i];
        if (node.layer < layer) {
            coarsen = false;
            break;
        }
    }

    if (coarsen)
    // if (0)
    {
        uint baseCode = nodesBuffer[uniqueStart].mortonCode;
        uint shift = layer * 3u;
        uint prefix = baseCode >> shift; // 3b-bit prefix
        uint3 coord = deinterleave(prefix);

        uint gridDim = 1u << (10 - layer);

        int3 deltas[6] = { int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1) };
        // [unroll]
        for (int d = 0; d < 6 && coarsen; d++)
        {
            int nx = (int)coord.x + deltas[d].x;
            int ny = (int)coord.y + deltas[d].y;
            int nz = (int)coord.z + deltas[d].z;

            // Bounds at this layer's grid (disabled for now)
            // if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
            // {
            //     coarsen = false;
            //     break;
            // }

            uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
            uint nPrefix = interleave(ncoord);

            uint lower = nPrefix << shift;
            uint upper = (nPrefix + 1u) << shift; // exclusive

            uint idx_low = lowerBoundMorton(lower);

            // this isn't perfect, but it's honestly fast enough. It's bounded to at most 8 iterations, and is robust.
            for (uint j = idx_low; j < numNodes; j++)
            {
                Node node = nodesBuffer[j];
                if (node.mortonCode >= upper)
                {
                    break;
                }
                if (node.layer < layer - 1)
                {
                    coarsen = false;
                    break;
                }
            }
        }
    }

    if (coarsen)
    {
        faceVelocities aggregatedVelocities;
        aggregatedVelocities.left = 0.0;
        aggregatedVelocities.right = 0.0;
        aggregatedVelocities.bottom = 0.0;
        aggregatedVelocities.top = 0.0;
        aggregatedVelocities.front = 0.0;
        aggregatedVelocities.back = 0.0;
        float3 weightedPosition = float3(0, 0, 0);
        float totalWeight = 0.0;
        uint minLayer = 11;

        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            float weight = pow(8.0, (float)node.layer);
            weightedPosition += node.position * weight;
            totalWeight += weight;
            aggregatedVelocities.left += node.velocities.left;
            aggregatedVelocities.right += node.velocities.right;
            aggregatedVelocities.bottom += node.velocities.bottom;
            aggregatedVelocities.top += node.velocities.top;
            aggregatedVelocities.front += node.velocities.front;
            aggregatedVelocities.back += node.velocities.back;
            minLayer = min(minLayer, node.layer);
        }

        // Safety check: prevent division by zero
        if (totalWeight > 0.0) {
            weightedPosition /= totalWeight;
        }

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocities = aggregatedVelocities;
        aggregatedNode.layer = minLayer;
        aggregatedNode.mortonCode = nodesBuffer[uniqueStart].mortonCode;
        aggregatedNode.active = 1;

        nodesBuffer[uniqueStart] = aggregatedNode;

        for (uint i = 1; i < numNodesInGroup; i++)
        {
            nodesBuffer[uniqueStart + i].active = 0;
        }
    } else {
        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            if (node.layer > layer) {
                nodesBuffer[i].layer = layer - 1;
            }
        }
    }
}