#pragma kernel CreateNodes
#pragma kernel ProcessNodes

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> sortedMortonCodes;             // input: sorted morton codes
RWStructuredBuffer<uint> sortedParticleIndices;         // input: sorted particle indices
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
RWStructuredBuffer<uint> uniqueCount;                   // input: number of unique codes
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes
RWStructuredBuffer<uint> nodeMortonCodes;               // output: morton codes for nodes
RWStructuredBuffer<uint> nodeIndices;                   // output: indices for nodes (0, 1, 2, ...)
RWStructuredBuffer<uint> nodeFlagsBuffer;               // output: initialized to 00 (packed flags)

uint numUniqueNodes;                                    // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer

[numthreads(64, 1, 1)]
void CreateNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;
    
    // Get the index into sorted arrays for this unique morton code
    uint sortedArrayIndex = uniqueIndices[threadIndex];
    
    // Find how many particles share this morton code
    uint particleCount = 1;
    uint nextUniqueIndex = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    
    // Aggregate particle data with weighted average
    float3 weightedPosition = float3(0, 0, 0);
    float3 weightedVelocity = float3(0, 0, 0);
    float totalWeight = 0.0;
    uint minLayer = 10;
    
    // Process all particles with this morton code
    for (uint i = sortedArrayIndex; i < nextUniqueIndex; i++)
    {
        uint particleIndex = sortedParticleIndices[i];
        Particle particle = particlesBuffer[particleIndex];
        
        // Weight = 8^(particle.layer), but since layer is always 0, weight = 8^0 = 1
        float weight = pow(8.0, (float)particle.layer);
        
        weightedPosition += particle.position * weight;
        weightedVelocity += particle.velocity * weight;
        totalWeight += weight;
        
        // Track minimum layer
        minLayer = min(minLayer, particle.layer);
    }
    
    // Normalize by total weight (center of mass)
    weightedPosition /= totalWeight;
    weightedVelocity /= totalWeight;

    uint mortonCode = particlesBuffer[sortedParticleIndices[sortedArrayIndex]].mortonCode;
    
    // Create the node
    Node node;
    node.position = weightedPosition;
    node.velocity = weightedVelocity;
    node.layer = minLayer;  // Use the minimum layer found
    // node.layer = totalWeight;
    node.mortonCode = mortonCode;
    
    // Write outputs
    nodesBuffer[threadIndex] = node;
    nodeMortonCodes[threadIndex] = mortonCode;
    nodeIndices[threadIndex] = threadIndex;  // Simple 0, 1, 2, ... sequence
    nodeFlagsBuffer[threadIndex] = 1;      // Initialize to 01
}

[numthreads(64, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint nodeIndex = id.x;
    if (nodeIndex >= numUniqueNodes) return;
    
    // Get the index into the nodes buffer for this unique prefix
    uint nodeBufferIndex = uniqueIndices[nodeIndex];
    uint nextNodeBufferIndex = nodeIndex +1 < numUniqueNodes ? uniqueIndices[nodeIndex + 1] : numNodes;
    
    uint activeNodes[8];
    uint numActiveNodes = 0;
    bool coarsen = true;

    for (uint i = nodeBufferIndex; i < nextNodeBufferIndex; i++)
    {
        if (nodeFlagsBuffer[i] == 1)
        {
            if (nodesBuffer[i].layer >= layer)
            {
                activeNodes[numActiveNodes] = i;
                numActiveNodes++;
                if (nodesBuffer[i].layer == layer)
                {
                    coarsen = false;
                }
            } else {
                coarsen = false;
            }
        }
    }

    if (numActiveNodes == 0) return;

    if (coarsen)
    {
        float3 weightedPosition = float3(0, 0, 0);
        float3 weightedVelocity = float3(0, 0, 0);
        float totalWeight = 0.0;
        uint minLayer = 11;

        for (uint i = 0; i < numActiveNodes; i++)
        {
            weightedPosition += nodesBuffer[activeNodes[i]].position * pow(8.0, (float)nodesBuffer[activeNodes[i]].layer);
            weightedVelocity += nodesBuffer[activeNodes[i]].velocity * pow(8.0, (float)nodesBuffer[activeNodes[i]].layer);
            totalWeight += pow(8.0, (float)nodesBuffer[activeNodes[i]].layer);
            minLayer = min(minLayer, nodesBuffer[activeNodes[i]].layer);
        }

        weightedPosition /= totalWeight;
        weightedVelocity /= totalWeight;

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocity = weightedVelocity;
        aggregatedNode.layer = minLayer;
        aggregatedNode.mortonCode = nodesBuffer[activeNodes[0]].mortonCode;

        nodesBuffer[nodeBufferIndex] = aggregatedNode;

        for (uint i = 1; i < numActiveNodes; i++)
        {
            nodeFlagsBuffer[activeNodes[i]] = 0;
        }
    } else {
        for (uint i = 0; i < numActiveNodes; i++)
        {
            nodesBuffer[activeNodes[i]].layer = layer;
        }
    }




    // // Check if this node is active
    // if (nodeFlagsBuffer[nodeBufferIndex] != 1) return;
    
    // // Find all nodes with the same prefix that are active
    // uint activeNodes[8];
    // uint numActiveNodes = 0;
    // bool coarsen = true;
    
    // // Search through the range of nodes for this unique prefix
    // for (uint i = nodeBufferIndex; i < nextNodeBufferIndex && numActiveNodes < 8; i++)
    // {
    //     if (nodeFlagsBuffer[i] == 1)
    //     {
    //         activeNodes[numActiveNodes] = i;
    //         numActiveNodes++;
    //         if (nodesBuffer[i].layer <= layer)
    //         {
    //             coarsen = false;
    //         }
    //     }
    // }
    
    // // Only coarsen if we have exactly 8 active nodes with the same prefix
    // if (numActiveNodes == 8 && coarsen)
    // {
    //     float3 weightedPosition = float3(0, 0, 0);
    //     float3 weightedVelocity = float3(0, 0, 0);
    //     float totalWeight = 0.0;
    //     uint minLayer = 10;

    //     // Aggregate all 8 active nodes
    //     for (uint j = 0; j < 8; j++)
    //     {
    //         uint idx = activeNodes[j];
    //         Node node = nodesBuffer[idx];
    //         float weight = pow(8.0, (float)node.layer);
    //         weightedPosition += node.position * weight;
    //         weightedVelocity += node.velocity * weight;
    //         totalWeight += weight;
            
    //         if (node.layer < minLayer)
    //         {
    //             minLayer = node.layer;
    //         }
    //     }

    //     if (totalWeight > 0.0)
    //     {
    //         weightedPosition /= totalWeight;
    //         weightedVelocity /= totalWeight;
    //     }

    //     // Create new aggregated node at the parent layer
    //     Node aggregatedNode;
    //     aggregatedNode.position = weightedPosition;
    //     aggregatedNode.velocity = weightedVelocity;
    //     aggregatedNode.layer = layer;  // Set to current hierarchical layer
    //     aggregatedNode.mortonCode = nodesBuffer[activeNodes[0]].mortonCode;
        
    //     // Store the aggregated node at the first position
    //     nodesBuffer[activeNodes[0]] = aggregatedNode;

    //     // Deactivate all other child nodes
    //     for (uint k = 1; k < 8; k++)
    //     {
    //         nodeFlagsBuffer[activeNodes[k]] = 0;
    //     }
    // } else {
    //     for (uint k = 0; k < 8; k++)
    //     {
    //         nodesBuffer[activeNodes[k]].layer = layer;
    //     }
    // }
}
