#pragma kernel CreateLeaves
#pragma kernel ProcessNodes

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes

uint numUniqueNodes;                              // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer

[numthreads(512, 1, 1)]
void CreateLeaves(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;
    
    // Get the index into sorted arrays for this unique morton code
    uint rangeStart = uniqueIndices[threadIndex];
    
    // Find how many particles share this morton code
    uint rangeEnd = threadIndex + 1 < numNodes ? uniqueIndices[threadIndex + 1] : numParticles;
    
    // Aggregate particle data with weighted average
    float3 weightedPosition = float3(0, 0, 0);
    
    float totalWeight = 0.0;
    uint minLayer = 11;
    
    // Process all particles with this morton code
    for (uint i = rangeStart; i < rangeEnd; i++)
    {
        Particle particle = particlesBuffer[i];
        
        // Weight = 8^(particle.layer), but since layer is always 0, weight = 8^0 = 1
        float weight = pow(8.0, (float)particle.layer);
        weightedPosition += particle.position * weight;
        totalWeight += weight;
        
        // Track minimum layer
        minLayer = min(minLayer, particle.layer);
    }
    
    // Normalize by total weight (center of mass)
    // Safety check: prevent division by zero
    if (totalWeight > 0.0) {
        weightedPosition /= totalWeight;
    }

    uint mortonCode = particlesBuffer[rangeStart].mortonCode;
    
    // Create the node
    Node node;
    node.position = weightedPosition;
    faceVelocities leafVelocities;
    leafVelocities.left = 0.0;
    leafVelocities.right = 0.0;
    leafVelocities.bottom = 0.0;
    leafVelocities.top = 0.0;
    leafVelocities.front = 0.0;
    leafVelocities.back = 0.0;
    node.velocities = leafVelocities;
    node.layer = minLayer;  // Use the minimum layer found
    node.mortonCode = mortonCode;
    node.active = 1;
    
    // Write outputs
    nodesBuffer[threadIndex] = node;
}

// [numthreads(512, 1, 1)]
// void ProcessLeaves(uint3 id : SV_DispatchThreadID)
// {
//     uint threadIndex = id.x;
//     if (threadIndex >= numUniqueActiveNodes) return;

//     uint sortedArrayIndex = uniqueIndices[threadIndex];
//     uint nextUniqueIndex = threadIndex + 1 < numUniqueActiveNodes ? uniqueIndices[threadIndex + 1] : numNodes;
//     uint numNodesInGroup = nextUniqueIndex - sortedArrayIndex;

//     if (numNodesInGroup == 0) return;

//     bool coarsen = true;
//     for (uint i = sortedArrayIndex; i < nextUniqueIndex; i++)
//     {
//         Node node = nodesBuffer[i];
//         if (node.layer <= layer) {
//             coarsen = false;
//             break;
//         }
//     }

//     if (coarsen)
//     {
//         float3 weightedPosition = float3(0, 0, 0);
//         float totalWeight = 0.0;
//         uint minLayer = 11;

//         for (uint i = sortedArrayIndex; i < nextUniqueIndex; i++)
//         {
//             Node node = nodesBuffer[i];
//             float weight = pow(8.0, (float)node.layer);
//             weightedPosition += node.position * weight;
//             totalWeight += weight;
//             minLayer = min(minLayer, node.layer);
//         }
        
//         // Safety check: prevent division by zero
//         if (totalWeight > 0.0) {
//             weightedPosition /= totalWeight;
//         }

//         Node aggregatedNode;
//         aggregatedNode.position = weightedPosition;
//         aggregatedNode.velocities = nodesBuffer[sortedArrayIndex].velocities;
//         aggregatedNode.layer = minLayer;
//         aggregatedNode.mortonCode = nodesBuffer[sortedArrayIndex].mortonCode;

//         nodesBuffer[sortedArrayIndex] = aggregatedNode;

//         for (uint i = 1; i < numNodesInGroup; i++)
//         {
//             nodeFlagsBuffer[sortedArrayIndex + i] = 0;
//         }
//     } else {
//         for (uint i = sortedArrayIndex; i < nextUniqueIndex; i++)
//         {
//             Node node = nodesBuffer[i];
//             if (node.layer > layer) {
//                 node.layer = layer - 1;
//             }
//         }
//     }
// }

[numthreads(512, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;

    uint uniqueStart = uniqueIndices[threadIndex];
    uint uniqueEnd = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    uint numNodesInGroup = uniqueEnd - uniqueStart;

    // Safety check: prevent infinite loops
    if (numNodesInGroup == 0 || uniqueStart >= uniqueEnd || uniqueEnd > numNodes) return;

    bool coarsen = true;
    for (uint i = uniqueStart; i < uniqueEnd; i++)
    {
        Node node = nodesBuffer[i];
        if (node.layer <= layer) {
            coarsen = false;
            break;
        }
    }

    if (coarsen)
    {
        float3 weightedPosition = float3(0, 0, 0);
        float totalWeight = 0.0;
        uint minLayer = 11;

        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            float weight = pow(8.0, (float)node.layer);
            weightedPosition += node.position * weight;
            totalWeight += weight;
            minLayer = min(minLayer, node.layer);
        }

        // Safety check: prevent division by zero
        if (totalWeight > 0.0) {
            weightedPosition /= totalWeight;
        }

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocities = nodesBuffer[uniqueStart].velocities;
        aggregatedNode.layer = minLayer;
        aggregatedNode.mortonCode = nodesBuffer[uniqueStart].mortonCode;
        aggregatedNode.active = 1;

        nodesBuffer[uniqueStart] = aggregatedNode;

        for (uint i = 1; i < numNodesInGroup; i++)
        {
            nodesBuffer[uniqueStart + i].active = 0;
        }
    } else {
        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            if (node.layer > layer) {
                nodesBuffer[i].layer = layer - 1;
            }
        }
    }
}

// [numthreads(512, 1, 1)]
// void CompactNodes(uint3 id : SV_DispatchThreadID)
// {
//     uint threadIndex = id.x;
//     if (threadIndex >= numActiveNodes) return;

//     activeNodesBuffer[threadIndex] = nodesBuffer[threadIndex];
// }