#pragma kernel CreateLeaves
#pragma kernel ProcessNodes
#pragma kernel pullVelocities
#pragma kernel copyFaceVelocities
#pragma kernel ApplyPressureGradient
#pragma kernel ApplyGravity
#pragma kernel EnforceBoundaryConditions

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Neighbors are stored as a flat buffer of 24 uints per node:
// [left4, right4, bottom4, top4, front4, back4]

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
RWStructuredBuffer<float> pressureBuffer;               // input: pressure values from CG solver
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes
RWStructuredBuffer<Node> tempNodesBuffer;               // output: per-node gathered face deltas
RWStructuredBuffer<uint> neighborsBuffer;               // output: neighbor indices per node (numNodes * 24)

uint numUniqueNodes;                              // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer
float deltaTime;                                        // time step for pressure gradient application
uint surfaceLayer;                                      // layer of the surface
float maxDetailCellSize;                               // smallest cell size for scaling
float velocitySensitivity;                              // sensitivity of velocity to layer
uint minLayer;                                      // initial layer
uint maxLayer;                                          // maximum layer
float3 simulationBoundsMin;                             // minimum simulation bounds
float3 simulationBoundsMax;                             // maximum simulation bounds

// Additional variables for particle creation
float3 mortonNormalizationFactor;
float mortonMaxValue;
float gravity;

// Morton helpers: interleave/deinterleave 3D (10 bits per axis)
uint3 deinterleave(uint m)
{
    uint x = 0, y = 0, z = 0;
    for (uint i = 0; i < 10; i++)
    {
        x |= ((m >> (3 * i + 0)) & 1) << i;
        y |= ((m >> (3 * i + 1)) & 1) << i;
        z |= ((m >> (3 * i + 2)) & 1) << i;
    }
    return uint3(x, y, z);
}

uint interleave(uint3 p)
{
    uint m = 0;
    for (uint i = 0; i < 10; i++)
    {
        m |= ((p.x & (1u << i)) << (2 * i + 0));
        m |= ((p.y & (1u << i)) << (2 * i + 1));
        m |= ((p.z & (1u << i)) << (2 * i + 2));
    }
    return m;
}

// 32-bit Morton code encoding function (adapted from 64-bit Swift/Metal version)
uint EncodeMorton3D(float3 pos)
{
    // Convert to uint32 and mask to 10 bits per axis (0x3FF = 1023 = 2^10-1)
    uint x = (uint)pos.x & 0x3FF;
    uint y = (uint)pos.y & 0x3FF;
    uint z = (uint)pos.z & 0x3FF;
    
    uint result = 0;
    
    // Interleave bits for 32-bit Morton code (10 bits per axis = 30 bits total)
    for (int i = 0; i < 10; i++) {
        result |= ((x & (1U << i)) << (2 * i));
        result |= ((y & (1U << i)) << (2 * i + 1));
        result |= ((z & (1U << i)) << (2 * i + 2));
    }
    
    return result;
}

// Helper: given direction d, return neighbor's opposing face value
float selectOpposingFace(faceVelocities v, int d)
{
    // d: 0=left,1=right,2=bottom,3=top,4=front,5=back
    if (d == 0) return v.right;
    if (d == 1) return v.left;
    if (d == 2) return v.top;
    if (d == 3) return v.bottom;
    if (d == 4) return v.back;
    return v.front; // d == 5
}

// Helper: subtract value from the correct face on outNode for direction d
void subtractToFace(inout Node outNode, int d, float value)
{
    if (d == 0) outNode.velocities.left -= value;
    else if (d == 1) outNode.velocities.right -= value;
    else if (d == 2) outNode.velocities.bottom -= value;
    else if (d == 3) outNode.velocities.top -= value;
    else if (d == 4) outNode.velocities.front -= value;
    else outNode.velocities.back -= value; // d == 5
}

// Helper: face offset inside 24-wide neighbors block
uint faceOffset(int d)
{
    // left=0..3, right=4..7, bottom=8..11, top=12..15, front=16..19, back=20..23
    if (d == 0) return 0u;
    if (d == 1) return 4u;
    if (d == 2) return 8u;
    if (d == 3) return 12u;
    if (d == 4) return 16u;
    return 20u; // d == 5
}

// Lower-bound search: first index with mortonCode >= target
// left is inclusive, right is exclusive
uint lowerBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound; // exclusive
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode < target)
        {
            left = mid + 1u;
        }
        else
        {
            right = mid;
        }
    }
    return left;
}

// Upper-bound search: last index with mortonCode <= target
// left_bound is inclusive, right_bound is exclusive
uint upperBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound;
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode > target)
        {
            right = mid;
        }
        else
        {
            left = mid + 1u;
        }
    }
    return left - 1u; // return last position where code <= target
}

[numthreads(512, 1, 1)]
void CreateLeaves(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;
    
    // Get the index into sorted arrays for this unique morton code
    uint rangeStart = uniqueIndices[threadIndex];
    
    // Find how many particles share this morton code
    uint rangeEnd = threadIndex + 1 < numNodes ? uniqueIndices[threadIndex + 1] : numParticles;
    
    // Aggregate particle data with weighted average
    float3 weightedPosition = float3(0, 0, 0);
    faceVelocities leafVelocities;
    leafVelocities.left = 0.0;
    leafVelocities.right = 0.0;
    leafVelocities.bottom = 0.0;
    leafVelocities.top = 0.0;
    leafVelocities.front = 0.0;
    leafVelocities.back = 0.0;
    
    float count = 0.0;
    uint minSubLayer = maxLayer;
    
    // Process all particles with this morton code
    for (uint i = rangeStart; i < rangeEnd; i++)
    {
        Particle particle = particlesBuffer[i];
        
        count += 1.0;
        weightedPosition += particle.position;

        float3 velocity = particle.velocity;
        if (velocity.x < 0) {
            leafVelocities.left += (-velocity.x);
        } else {
            leafVelocities.right += velocity.x;
        }
        if (velocity.y < 0) {
            leafVelocities.bottom += (-velocity.y);
        } else {
            leafVelocities.top += velocity.y;
        }
        if (velocity.z < 0) {
            leafVelocities.front += (-velocity.z);
        } else {
            leafVelocities.back += velocity.z;
        }
        
        // Track minimum layer
        minSubLayer = min(minSubLayer, particle.layer);
    }
    
    // Normalize by total weight (center of mass)
    // Safety check: prevent division by zero
    if (count > 0.0) {
        weightedPosition /= count;
        // Average face velocities by weight as well
        leafVelocities.left /= count;
        leafVelocities.right /= count;
        leafVelocities.bottom /= count;
        leafVelocities.top /= count;
        leafVelocities.front /= count;
        leafVelocities.back /= count;
    }

    uint mortonCode = particlesBuffer[rangeStart].mortonCode;

    // weightedPosition = clamp(weightedPosition, simulationBoundsMin, simulationBoundsMax);
    
    // Create the node
    Node node;
    node.position = weightedPosition;
    node.velocities = leafVelocities;
    node.layer = minSubLayer;  // Use the minimum layer found
    node.mass = count;
    node.mortonCode = mortonCode;
    node.active = 1u; // Set last bit to 1
    
    // Write outputs
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;

    uint uniqueStart = uniqueIndices[threadIndex];
    uint uniqueEnd = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    uint numNodesInGroup = uniqueEnd - uniqueStart;

    // Safety check: prevent infinite loops
    if (numNodesInGroup <= 1 || uniqueStart >= uniqueEnd || uniqueEnd > numNodes) return;

    bool coarsen = true;
    for (uint i = uniqueStart; i < uniqueEnd; i++)
    {
        Node node = nodesBuffer[i];
        if (node.layer < layer) {
            coarsen = false;
            break;
        }
    }

    if (coarsen)
    {
        uint baseCode = nodesBuffer[uniqueStart].mortonCode;
        uint shift = layer * 3u;
        uint prefix = baseCode >> shift; // 3b-bit prefix
        uint3 coord = deinterleave(prefix);

        uint gridDim = 1u << (10 - layer);

        uint numNeighbors = 0;

        int3 deltas[6] = { int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1) };
        // [unroll]
        for (int d = 0; d < 6 && coarsen; d++)
        {
            int nx = (int)coord.x + deltas[d].x;
            int ny = (int)coord.y + deltas[d].y;
            int nz = (int)coord.z + deltas[d].z;

            // Bounds at this layer's grid (disabled for now)
            // if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
            // {
            //     coarsen = false;
            //     break;
            // }

            uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
            uint nPrefix = interleave(ncoord);

            uint lower = nPrefix << shift;
            uint upper = (nPrefix + 1u) << shift; // exclusive

            int subNodesLower[4];
            if (d == 0) { // right face
                subNodesLower[0] = 1;
                subNodesLower[1] = 3;
                subNodesLower[2] = 5;
                subNodesLower[3] = 7;
            } else if (d == 1) { // left face
                subNodesLower[0] = 0;
                subNodesLower[1] = 2;
                subNodesLower[2] = 4;
                subNodesLower[3] = 6;
            } else if (d == 2) { // top face
                subNodesLower[0] = 2;
                subNodesLower[1] = 3;
                subNodesLower[2] = 6;
                subNodesLower[3] = 7;
            } else if (d == 3) { // bottom face
                subNodesLower[0] = 0;
                subNodesLower[1] = 1;
                subNodesLower[2] = 4;
                subNodesLower[3] = 5;
            } else if (d == 4) { // back face
                subNodesLower[0] = 4;
                subNodesLower[1] = 5;
                subNodesLower[2] = 6;
                subNodesLower[3] = 7;
            } else if (d == 5) { // front face
                subNodesLower[0] = 0;
                subNodesLower[1] = 1;
                subNodesLower[2] = 2;
                subNodesLower[3] = 3;
            }

            uint nPrefixShifted = nPrefix << 3;
            for (int i = 0; i < 4 && coarsen; i++)
            {
                uint subPrefix = nPrefixShifted + subNodesLower[i];
                uint subLower = subPrefix << (shift - 3);
                uint subUpper = (subPrefix + 1u) << (shift - 3);
                uint idx_sub = lowerBoundMorton(subLower, 0, numNodes);
                if (idx_sub < numNodes)
                {
                    Node cNode = nodesBuffer[idx_sub];
                    if (cNode.mortonCode < subUpper)
                    {
                        if (cNode.layer < layer - 1)
                        {
                            coarsen = false;
                        }
                        numNeighbors++;
                    }
                }
            }
        }
        if (numNeighbors < 8 && layer > surfaceLayer) {
            coarsen = false;
        }
    }

    if (coarsen)
    {
        faceVelocities aggregatedVelocities;
        aggregatedVelocities.left = 0.0;
        aggregatedVelocities.right = 0.0;
        aggregatedVelocities.bottom = 0.0;
        aggregatedVelocities.top = 0.0;
        aggregatedVelocities.front = 0.0;
        aggregatedVelocities.back = 0.0;
        float3 weightedPosition = float3(0, 0, 0);
        float totalMass = 0.0;
        uint minSubLayer = maxLayer;

        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            float mass = node.mass;
            weightedPosition += node.position * mass;
            totalMass += mass;
            aggregatedVelocities.left += node.velocities.left * mass;
            aggregatedVelocities.right += node.velocities.right * mass;
            aggregatedVelocities.bottom += node.velocities.bottom * mass;
            aggregatedVelocities.top += node.velocities.top * mass;
            aggregatedVelocities.front += node.velocities.front * mass;
            aggregatedVelocities.back += node.velocities.back * mass;
            minSubLayer = min(minSubLayer, node.layer);
        }

        // Safety check: prevent division by zero
        if (totalMass > 0.0) {
            weightedPosition /= totalMass;
            aggregatedVelocities.left /= totalMass;
            aggregatedVelocities.right /= totalMass;
            aggregatedVelocities.bottom /= totalMass;
            aggregatedVelocities.top /= totalMass;
            aggregatedVelocities.front /= totalMass;
            aggregatedVelocities.back /= totalMass;
        }

        // weightedPosition = clamp(weightedPosition, simulationBoundsMin, simulationBoundsMax);

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocities = aggregatedVelocities;
        aggregatedNode.layer = minSubLayer;
        aggregatedNode.mass = totalMass;
        aggregatedNode.mortonCode = nodesBuffer[uniqueStart].mortonCode;
        aggregatedNode.active = 1u; // Set last bit to 1

        nodesBuffer[uniqueStart] = aggregatedNode;

        for (uint j = 1; j < numNodesInGroup; j++)
        {
            nodesBuffer[uniqueStart + j].active = 0u; // Set last bit to 0
        }
    } else {
        for (uint j = uniqueStart; j < uniqueEnd; j++)
        {
            Node node = nodesBuffer[j];
            if (node.layer > layer) {
                nodesBuffer[j].layer = layer - 1;
            }
        }
    }
}

// Next step: handle bigger than current layer
// Do multiplier when aggregating based on layer

[numthreads(512, 1, 1)]
void pullVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    faceVelocities selfVel = node.velocities;

    // Initialize output (delta) node with zero face velocities
    Node outNode;
    outNode.position = node.position;
    outNode.mass = node.mass;
    outNode.layer = node.layer;
    outNode.mortonCode = node.mortonCode;
    outNode.active = node.active;
    outNode.velocities = selfVel;

    // Initialize neighbors to invalid index (numNodes) for all 24 slots
    uint nbBase = threadIndex * 24;
    for (uint k = 0; k < 24; k++)
    {
        neighborsBuffer[nbBase + k] = numNodes;
    }

    // all face neighbors of this node. It's bounded to 2:1 ratio
    int3 deltas[6] = {int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1)};
    for (int d = 0; d < 6; d++)
    {
        uint shift = node.layer * 3;
        uint prefix = node.mortonCode >> shift;
        uint3 coord = deinterleave(prefix);

        int nx = (int)coord.x + deltas[d].x;
        int ny = (int)coord.y + deltas[d].y;
        int nz = (int)coord.z + deltas[d].z;
        
        // Skip if neighbor is outside the grid bounds for this layer
        uint gridDim = 1u << (10 - node.layer);
        if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
        {
            // // Zero the boundary face velocity for solid walls
            // if (d == 0) { // Left boundary
            //     outNode.velocities.right += selfVel.left;
            //     outNode.velocities.left = 0;
            // } else if (d == 1) { // Right boundary
            //     outNode.velocities.left += selfVel.right;
            //     outNode.velocities.right = 0;
            // } else if (d == 2) { // Bottom boundary
            //     outNode.velocities.top += selfVel.bottom;
            //     outNode.velocities.bottom = 0;
            // } else if (d == 3) { // Top boundary
            //     outNode.velocities.bottom += selfVel.top;
            //     outNode.velocities.top = 0;
            // } else if (d == 4) { // Front boundary
            //     outNode.velocities.back += selfVel.front;
            //     outNode.velocities.front = 0;
            // } else if (d == 5) { // Back boundary
            //     outNode.velocities.front += selfVel.back;
            //     outNode.velocities.back = 0;
            // }
            continue; // Skip this neighbor direction
        }
        
        uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
        uint nPrefix = interleave(ncoord);

        // same-layer neighbor: leq prefix will fall under eq. Layer will be eq.
        // parent neighbor: leq prefix fill fall under less or equal, but layer will be +1
        // child neighbor: search geq for lower and upper bounds. Layer will be -1, operate on all 4 subnodes.

        uint target = nPrefix << shift;
        uint upper = (nPrefix + 1u) << shift; // start of next region

        // Find the last node in this region by finding first node in next region, then subtract 1
        uint idx_next = lowerBoundMorton(upper, 0, numNodes);
        uint idx_leq = (idx_next > 0) ? idx_next - 1u : 0u;

        // Skip if no valid neighbor found
        if (idx_leq >= numNodes) continue;

        Node nNode = nodesBuffer[idx_leq];
        uint idx_leq_mc = nNode.mortonCode;
        uint idx_leq_mc_prefix = idx_leq_mc >> shift;
        uint idx_leq_layer = nNode.layer;

        if (idx_leq_mc_prefix == nPrefix && idx_leq_layer == node.layer)
        {
            // same-layer neighbor
            float opp = selectOpposingFace(nNode.velocities, d);
            subtractToFace(outNode, d, opp);
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else if ((idx_leq_mc >> (shift + 3)) == (nPrefix >> 3) && idx_leq_layer == node.layer + 1)
        {
            // parent neighbor (divide incoming velocity by 4)
            float oppP = selectOpposingFace(nNode.velocities, d) * 0.25;
            subtractToFace(outNode, d, oppP);
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else
        {
            // Initialize all 4 positions with invalid neighbor index
            for (int i = 0; i < 4; i++)
            {
                neighborsBuffer[threadIndex * 24 + faceOffset(d) + i] = numNodes + 1;
            }
            
            // child neighbor path only valid if shift >= 3 (layer >= 1)
            if (shift >= 3)
            {
                uint idx_target = lowerBoundMorton(target, 0, numNodes); // low child bound
                uint idx_upper = lowerBoundMorton(upper, 0, numNodes); // high child bound
                if (idx_target < idx_upper)
                {
                    uint nPrefixShifted = nPrefix << 3;
                    int subNodesLower[4];
                    if (d == 0) { // right face
                        subNodesLower[0] = 1;
                        subNodesLower[1] = 3;
                        subNodesLower[2] = 5;
                        subNodesLower[3] = 7;
                    } else if (d == 1) { // left face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 2;
                        subNodesLower[2] = 4;
                        subNodesLower[3] = 6;
                    } else if (d == 2) { // top face
                        subNodesLower[0] = 2;
                        subNodesLower[1] = 3;
                        subNodesLower[2] = 6;
                        subNodesLower[3] = 7;
                    } else if (d == 3) { // bottom face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 1;
                        subNodesLower[2] = 4;
                        subNodesLower[3] = 5;
                    } else if (d == 4) { // back face
                        subNodesLower[0] = 4;
                        subNodesLower[1] = 5;
                        subNodesLower[2] = 6;
                        subNodesLower[3] = 7;
                    } else if (d == 5) { // front face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 1;
                        subNodesLower[2] = 2;
                        subNodesLower[3] = 3;
                    }
                    
                    for (int i = 0; i < 4; i++)
                    {
                        uint subPrefix = nPrefixShifted + subNodesLower[i];
                        uint subLower = subPrefix << (shift - 3);
                        uint subUpper = (subPrefix + 1u) << (shift - 3);
                        uint idx_sub = lowerBoundMorton(subLower, idx_target, idx_upper);
                        if (idx_sub < idx_upper)
                        {
                            Node cNode = nodesBuffer[idx_sub];
                            uint idx_sub_mc = cNode.mortonCode;
                            uint idx_sub_mc_prefix = idx_sub_mc >> (shift - 3);
                            uint idx_sub_layer = cNode.layer;
                            if (idx_sub_mc_prefix == subPrefix && idx_sub_layer == node.layer - 1)
                            {
                                float oppC = selectOpposingFace(cNode.velocities, d);
                                subtractToFace(outNode, d, oppC);
                                neighborsBuffer[threadIndex * 24 + faceOffset(d) + i] = idx_sub;
                            }
                        }
                    }
                }
            }
        }
    }

    // Write gathered deltas to temp buffer for this node
    tempNodesBuffer[threadIndex] = outNode;
}

[numthreads(512, 1, 1)]
void copyFaceVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    nodesBuffer[threadIndex] = tempNodesBuffer[threadIndex];
}

[numthreads(512, 1, 1)]
void ApplyPressureGradient(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    Node outNode = node; // Start with a copy
    float p_i = pressureBuffer[threadIndex];
    float dx_i = max(maxDetailCellSize * exp2((float)node.layer), 1e-6);

    uint neighborBaseIndex = threadIndex * 24;

    // Loop through all 6 faces, same as pullVelocities and ApplyLaplacian
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBaseIndex + d * 4;
        uint neighbor_idx = neighborsBuffer[faceNeighborBase];
        float pressure_gradient = 0.0;
        bool isBoundary = (neighbor_idx >= numNodes);

        if (!isBoundary && nodesBuffer[neighbor_idx].layer >= node.layer)
        {
            // Case 1: Same-layer or Parent (coarser) neighbor
            Node nNode = nodesBuffer[neighbor_idx];
            float p_j = pressureBuffer[neighbor_idx];
            float dx_j = max(maxDetailCellSize * exp2((float)nNode.layer), 1e-6);
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            pressure_gradient = (p_j - p_i) / distance;
        }
        else if (!isBoundary && dx_i > 0.0)
        {
            // Case 2: Child (finer) neighbors
            float avg_p_children = 0.0;
            uint childCount = 0;
            for (int k = 0; k < 4; k++)
            {
                uint child_idx = neighborsBuffer[faceNeighborBase + k];
                if (child_idx < numNodes)
                {
                    avg_p_children += pressureBuffer[child_idx];
                    childCount++;
                }
            }

            if (childCount > 0)
            {
                avg_p_children /= (float)childCount;
                float dx_child = dx_i * 0.5;
                float distance = max(0.5 * (dx_i + dx_child), 1e-6);
                pressure_gradient = (avg_p_children - p_i) / distance;
            }
        }
        
        float velocity_correction = deltaTime * pressure_gradient;

        if (d == 0) outNode.velocities.left -= velocity_correction;
        else if (d == 1) outNode.velocities.right -= velocity_correction;
        else if (d == 2) outNode.velocities.bottom -= velocity_correction;
        else if (d == 3) outNode.velocities.top -= velocity_correction;
        else if (d == 4) outNode.velocities.front -= velocity_correction;
        else outNode.velocities.back -= velocity_correction;
    }

    tempNodesBuffer[threadIndex] = outNode;
}

[numthreads(512, 1, 1)]
void ApplyGravity(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    node.velocities.top -= gravity * deltaTime;
    node.velocities.bottom += gravity * deltaTime;
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void EnforceBoundaryConditions(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    
    uint shift = node.layer * 3;
    uint prefix = node.mortonCode >> shift;
    uint3 coord = deinterleave(prefix);
    uint gridDim = 1u << (10 - node.layer);

    // Check X boundaries
    if (coord.x == 0) node.velocities.left = 0;
    if (coord.x == gridDim - 1) node.velocities.right = 0;
    
    // Check Y boundaries
    if (coord.y == 0) node.velocities.bottom = 0;
    if (coord.y == gridDim - 1) node.velocities.top = 0;

    // Check Z boundaries
    if (coord.z == 0) node.velocities.front = 0;
    if (coord.z == gridDim - 1) node.velocities.back = 0;
    
    nodesBuffer[threadIndex] = node;
}