#pragma kernel CreateLeaves
#pragma kernel ProcessNodes
#pragma kernel findNeighbors
#pragma kernel interpolateFaceVelocities
#pragma kernel copyFaceVelocities
#pragma kernel ApplyPressureGradient
#pragma kernel ApplyGravity
#pragma kernel EnforceBoundaryConditions
#pragma kernel InitializePhi
#pragma kernel PropagatePhi

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Particle struct (must match C# struct)
struct Particle
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Neighbors are stored as a flat buffer of 24 uints per node:
// [left4, right4, bottom4, top4, front4, back4]

// Input buffers
RWStructuredBuffer<Particle> particlesBuffer;           // input: all particles
RWStructuredBuffer<uint> uniqueIndices;                 // input: indices of first occurrence of each unique code
RWStructuredBuffer<float> pressureBuffer;               // input: pressure values from CG solver
// Output buffers
RWStructuredBuffer<Node> nodesBuffer;                   // output: aggregated nodes
RWStructuredBuffer<Node> tempNodesBuffer;               // output: per-node gathered face deltas
RWStructuredBuffer<uint> neighborsBuffer;               // output: neighbor indices per node (numNodes * 24)
RWStructuredBuffer<float> phiBuffer;                    // level set distance field (read/write)
StructuredBuffer<float> phiBuffer_Read;                 // level set distance field (read-only copy for propagation)
RWStructuredBuffer<uint> dirtyFlagBuffer;               // single-element buffer for convergence flag

uint numUniqueNodes;                              // number of unique morton codes
uint numNodes;                                          // number of nodes
uint numParticles;                                      // total number of particles
uint layer;                                             // current hierarchical layer
float deltaTime;                                        // time step for pressure gradient application
uint minLayer;                                      // initial layer
uint maxLayer;                                          // maximum layer
float3 simulationBoundsMin;                             // minimum simulation bounds
float3 simulationBoundsMax;                             // maximum simulation bounds

// Additional variables for particle creation
float3 mortonNormalizationFactor;
float mortonMaxValue;
float gravity;

// Morton helpers: interleave/deinterleave 3D (10 bits per axis)
uint3 deinterleave(uint m)
{
    uint x = 0, y = 0, z = 0;
    for (uint i = 0; i < 10; i++)
    {
        x |= ((m >> (3 * i + 0)) & 1) << i;
        y |= ((m >> (3 * i + 1)) & 1) << i;
        z |= ((m >> (3 * i + 2)) & 1) << i;
    }
    return uint3(x, y, z);
}

uint interleave(uint3 p)
{
    uint m = 0;
    for (uint i = 0; i < 10; i++)
    {
        m |= (((p.x >> i) & 1u) << (3 * i + 0));
        m |= (((p.y >> i) & 1u) << (3 * i + 1));
        m |= (((p.z >> i) & 1u) << (3 * i + 2));
    }
    return m;
}

// 32-bit Morton code encoding function (adapted from 64-bit Swift/Metal version)
uint EncodeMorton3D(float3 pos)
{
    // Convert to uint32 and mask to 10 bits per axis (0x3FF = 1023 = 2^10-1)
    uint x = (uint)pos.x & 0x3FF;
    uint y = (uint)pos.y & 0x3FF;
    uint z = (uint)pos.z & 0x3FF;
    
    uint result = 0;
    
    // Interleave bits for 32-bit Morton code (10 bits per axis = 30 bits total)
    for (int i = 0; i < 10; i++) {
        result |= (((x >> i) & 1u) << (3 * i));
        result |= (((y >> i) & 1u) << (3 * i + 1));
        result |= (((z >> i) & 1u) << (3 * i + 2));
    }
    
    return result;
}

// Helper: face offset inside 24-wide neighbors block
uint faceOffset(int d)
{
    // left=0..3, right=4..7, bottom=8..11, top=12..15, front=16..19, back=20..23
    if (d == 0) return 0u;
    if (d == 1) return 4u;
    if (d == 2) return 8u;
    if (d == 3) return 12u;
    if (d == 4) return 16u;
    return 20u; // d == 5
}

float selectFace(faceVelocities v, int d)
{
    if (d == 0) return v.left;
    if (d == 1) return v.right;
    if (d == 2) return v.bottom;
    if (d == 3) return v.top;
    if (d == 4) return v.front;
    return v.back;
}

float selectOpposingFace(faceVelocities v, int d)
{
    if (d == 0) return v.right;
    if (d == 1) return v.left;
    if (d == 2) return v.top;
    if (d == 3) return v.bottom;
    if (d == 4) return v.back;
    return v.front;
}

// Lower-bound search: first index with mortonCode >= target
// left is inclusive, right is exclusive
uint lowerBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound; // exclusive
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode < target)
        {
            left = mid + 1u;
        }
        else
        {
            right = mid;
        }
    }
    return left;
}

// Upper-bound search: last index with mortonCode <= target
// left_bound is inclusive, right_bound is exclusive
uint upperBoundMorton(uint target, uint left_bound, uint right_bound)
{
    uint left = left_bound;
    uint right = right_bound;
    while (left < right)
    {
        uint mid = left + ((right - left) >> 1);
        uint midCode = nodesBuffer[mid].mortonCode;
        if (midCode > target)
        {
            right = mid;
        }
        else
        {
            left = mid + 1u;
        }
    }
    return left - 1u; // return last position where code <= target
}

[numthreads(512, 1, 1)]
void CreateLeaves(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;
    
    // Get the index range for particles in this node
    uint rangeStart = uniqueIndices[threadIndex];
    uint rangeEnd = threadIndex + 1 < numNodes ?
        uniqueIndices[threadIndex + 1] : numParticles;

    // --- Define Node Geometry ---
    uint nodeLayer = minLayer;
    uint mortonCode = particlesBuffer[rangeStart].mortonCode;
    
    // Calculate node's world-space bounds (logic from UpdateParticles)
    float cellSideLength = exp2((float)nodeLayer);
    uint cellMortonCode = mortonCode & ~((1u << (3 * nodeLayer)) - 1);
    uint3 cellGridMin = deinterleave(cellMortonCode);
    
    float3 nodeMin = cellGridMin;
    float3 extent = float3(cellSideLength, cellSideLength, cellSideLength);

    // --- Initialize Aggregation Variables ---
    float3 weightedPosition = float3(0, 0, 0);
    float3 weightedVelocity = float3(0, 0, 0);
    float count = 0.0;

    // Initialize face velocities and weights for normalization
    faceVelocities leafVelocities;
    leafVelocities.left = 0.0;
    leafVelocities.right = 0.0;
    leafVelocities.bottom = 0.0;
    leafVelocities.top = 0.0;
    leafVelocities.front = 0.0;
    leafVelocities.back = 0.0;

    faceVelocities leafWeights; // Accumulate weights for normalization
    leafWeights.left = 0.0;
    leafWeights.right = 0.0;
    leafWeights.bottom = 0.0;
    leafWeights.top = 0.0;
    leafWeights.front = 0.0;
    leafWeights.back = 0.0;

    // --- Pass 2: Aggregate and Splat Velocities ---
    for (uint i = rangeStart; i < rangeEnd; i++)
    {
        Particle particle = particlesBuffer[i];
        count += 1.0;
        
        // Aggregate cell-centered data (for coarsening)
        weightedPosition += particle.position;
        weightedVelocity += particle.velocity;
        
        // --- Particle-to-Grid Splatting ---
        // Get normalized position (0-1) within the node
        float3 t = saturate((particle.position - nodeMin) / extent);

        // This splat reverses the interpolation from UpdateParticles
        // We splat each velocity component to its two corresponding faces
        
        // Splat X velocity (to Left/Right faces)
        float w_x_left = (1.0 - t.x); // Weight for left face
        float w_x_right = t.x;        // Weight for right face
        leafVelocities.left += particle.velocity.x * w_x_left;
        leafVelocities.right += particle.velocity.x * w_x_right;
        leafWeights.left += w_x_left;
        leafWeights.right += w_x_right;

        // Splat Y velocity (to Bottom/Top faces)
        float w_y_bottom = (1.0 - t.y); // Weight for bottom face
        float w_y_top = t.y;          // Weight for top face
        leafVelocities.bottom += particle.velocity.y * w_y_bottom;
        leafVelocities.top += particle.velocity.y * w_y_top;
        leafWeights.bottom += w_y_bottom;
        leafWeights.top += w_y_top;

        // Splat Z velocity (to Front/Back faces)
        float w_z_front = (1.0 - t.z); // Weight for front face
        float w_z_back = t.z;         // Weight for back face
        leafVelocities.front += particle.velocity.z * w_z_front;
        leafVelocities.back += particle.velocity.z * w_z_back;
        leafWeights.front += w_z_front;
        leafWeights.back += w_z_back;
    }
    
    // --- Normalize Aggregated Data ---
    if (count > 0.0) {
        weightedPosition /= count;
        weightedVelocity /= count;
    }

    // Normalize face velocities by their accumulated weights
    float epsilon = 1e-9; // Avoid division by zero
    leafVelocities.left   /= max(epsilon, leafWeights.left);
    leafVelocities.right  /= max(epsilon, leafWeights.right);
    leafVelocities.bottom /= max(epsilon, leafWeights.bottom);
    leafVelocities.top    /= max(epsilon, leafWeights.top);
    leafVelocities.front  /= max(epsilon, leafWeights.front);
    leafVelocities.back   /= max(epsilon, leafWeights.back);

    // --- Create the Final Node ---
    Node node;
    node.position = weightedPosition;
    node.velocity = weightedVelocity;
    node.velocities = leafVelocities; // Store the splatted face velocities
    node.layer = maxLayer;
    node.mass = count;
    node.mortonCode = mortonCode;
    node.active = 1u;
    
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void ProcessNodes(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numUniqueNodes) return;

    uint uniqueStart = uniqueIndices[threadIndex];
    uint uniqueEnd = threadIndex + 1 < numUniqueNodes ? uniqueIndices[threadIndex + 1] : numNodes;
    uint numNodesInGroup = uniqueEnd - uniqueStart;

    // Safety check: prevent infinite loops
    if (numNodesInGroup <= 1 || uniqueStart >= uniqueEnd || uniqueEnd > numNodes) return;

    bool coarsen = true;
    for (uint i = uniqueStart; i < uniqueEnd; i++)
    {
        Node node = nodesBuffer[i];
        if (node.layer < layer) {
            coarsen = false;
            break;
        }
    }

    if (coarsen)
    {
        uint baseCode = nodesBuffer[uniqueStart].mortonCode;
        uint shift = layer * 3u;
        uint prefix = baseCode >> shift; // 3b-bit prefix
        uint3 coord = deinterleave(prefix);

        uint gridDim = 1u << (10 - layer);

        uint numNeighbors = 0;

        int3 deltas[6] = { int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1) };
        for (int d = 0; d < 6 && coarsen; d++)
        {
            int nx = (int)coord.x + deltas[d].x;
            int ny = (int)coord.y + deltas[d].y;
            int nz = (int)coord.z + deltas[d].z;

            // Bounds at this layer's grid
            if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
            {
                continue;
            }

            uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
            uint nPrefix = interleave(ncoord);

            uint target = nPrefix << shift;
            uint upper = (nPrefix + 1u) << shift; // start of next region

            // Find the last node in this region by finding first node in next region, then subtract 1
            uint idx_next = lowerBoundMorton(upper, 0, numNodes);
            uint idx_leq = (idx_next > 0) ? idx_next - 1u : 0u;

            // Skip if no valid neighbor found
            if (idx_leq >= numNodes)
            {
                coarsen = false;
                break;
            }

            Node nNode = nodesBuffer[idx_leq];
            uint idx_leq_mc = nNode.mortonCode;
            uint idx_leq_mc_prefix = idx_leq_mc >> shift;
            uint idx_leq_layer = nNode.layer;

            if (idx_leq_mc_prefix == nPrefix && idx_leq_layer >= layer) {
                continue;
            }
            // else if ((idx_leq_mc >> (shift + 3)) == (nPrefix >> 3) && idx_leq_layer >= layer + 1) {
            //     continue;
            // }
            else {
                // Child neighbor case: need to verify all 4 child nodes exist
                if (shift >= 3) {
                    uint idx_target = lowerBoundMorton(target, 0, numNodes); // low child bound
                    uint idx_upper = lowerBoundMorton(upper, 0, numNodes); // high child bound
                    if (idx_target < idx_upper)
                    {
                        uint nPrefixShifted = nPrefix << 3;
                        int subNodesLower[4];
                        if (d == 0) { // right face
                            subNodesLower[0] = 1;
                            subNodesLower[1] = 3;
                            subNodesLower[2] = 5;
                            subNodesLower[3] = 7;
                        } else if (d == 1) { // left face
                            subNodesLower[0] = 0;
                            subNodesLower[1] = 2;
                            subNodesLower[2] = 4;
                            subNodesLower[3] = 6;
                        } else if (d == 2) { // top face
                            subNodesLower[0] = 2;
                            subNodesLower[1] = 3;
                            subNodesLower[2] = 6;
                            subNodesLower[3] = 7;
                        } else if (d == 3) { // bottom face
                            subNodesLower[0] = 0;
                            subNodesLower[1] = 1;
                            subNodesLower[2] = 4;
                            subNodesLower[3] = 5;
                        } else if (d == 4) { // back face
                            subNodesLower[0] = 4;
                            subNodesLower[1] = 5;
                            subNodesLower[2] = 6;
                            subNodesLower[3] = 7;
                        } else if (d == 5) { // front face
                            subNodesLower[0] = 0;
                            subNodesLower[1] = 1;
                            subNodesLower[2] = 2;
                            subNodesLower[3] = 3;
                        }
                        
                        uint validChildCount = 0;

                        for (int i = 0; i < 4; i++)
                        {
                            uint subPrefix = nPrefixShifted + subNodesLower[i];
                            uint subLower = subPrefix << (shift - 3);
                            uint subUpper = (subPrefix + 1u) << (shift - 3);
                            uint idx_sub = lowerBoundMorton(subLower, idx_target, idx_upper);
                            
                            // Verify the child node exists and is valid
                            if (idx_sub < idx_upper)
                            {
                                Node cNode = nodesBuffer[idx_sub];
                                uint idx_sub_mc = cNode.mortonCode;
                                uint idx_sub_mc_prefix = idx_sub_mc >> (shift - 3);
                                uint idx_sub_layer = cNode.layer;
                                
                                // Check if this is the correct child node
                                if (idx_sub_mc_prefix == subPrefix && idx_sub_layer >= layer - 1)
                                {
                                    validChildCount++;
                                }
                            }
                        }
                    }
                }
                // If we reach here, neighbor validation failed
                coarsen = false;
                break;
            }
        }
    }

    if (coarsen)
    {
        float3 weightedVelocity = float3(0, 0, 0);
        float3 weightedPosition = float3(0, 0, 0);
        float totalMass = 0.0;
        uint minSubLayer = maxLayer;

        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node node = nodesBuffer[i];
            float mass = node.mass;
            weightedPosition += node.position * mass;
            weightedVelocity += node.velocity * mass;
            totalMass += mass;
            minSubLayer = min(minSubLayer, node.layer);
        }

        // Safety check: prevent division by zero
        if (totalMass > 0.0) {
            weightedPosition /= totalMass;
            weightedVelocity /= totalMass;
        }

        // --- Coarsen Face Velocities: Average external faces from children ---
        // Children are ordered by morton code: 0=(0,0,0), 1=(1,0,0), 2=(0,1,0), 3=(1,1,0),
        //                                      4=(0,0,1), 5=(1,0,1), 6=(0,1,1), 7=(1,1,1)
        // External faces: only average faces that are on the boundary of the parent cell
        faceVelocities aggregatedVelocities;
        aggregatedVelocities.left = 0.0;
        aggregatedVelocities.right = 0.0;
        aggregatedVelocities.bottom = 0.0;
        aggregatedVelocities.top = 0.0;
        aggregatedVelocities.front = 0.0;
        aggregatedVelocities.back = 0.0;
        
        // Accumulate mass-weighted face velocities for each face (for mass-weighted averaging)
        float leftMass = 0.0;
        float rightMass = 0.0;
        float bottomMass = 0.0;
        float topMass = 0.0;
        float frontMass = 0.0;
        float backMass = 0.0;
        
        // Iterate through children and accumulate external face velocities
        // The children are already in the uniqueStart to uniqueEnd range
        uint baseCode = nodesBuffer[uniqueStart].mortonCode;
        uint parentShift = layer * 3;  // Parent's prefix is at this bit position
        uint childShift = (layer - 1) * 3;  // Children's prefix starts here
        uint parentPrefix = baseCode >> parentShift;
        
        for (uint i = uniqueStart; i < uniqueEnd; i++)
        {
            Node childNode = nodesBuffer[i];
            
            // Extract the child prefix and check if it belongs to this parent
            uint childMortonCode = childNode.mortonCode;
            uint childPrefix = childMortonCode >> childShift;
            
            // Check if this child belongs to this parent (parent prefix matches child prefix >> 3)
            if ((childPrefix >> 3) != parentPrefix) continue;
            
            // Extract child octant index (0-7) from the last 3 bits of childPrefix
            // These are the 3 bits that determine which octant of the parent this child occupies
            uint childIdx = childPrefix & 0x7;
            float childMass = childNode.mass;
            
            // Accumulate mass-weighted external face velocities based on child position
            // Left face (x=0): children 0, 2, 4, 6
            if ((childIdx & 1) == 0) // x bit is 0
            {
                aggregatedVelocities.left += childNode.velocities.left * childMass;
                leftMass += childMass;
            }
            
            // Right face (x=1): children 1, 3, 5, 7
            if ((childIdx & 1) == 1) // x bit is 1
            {
                aggregatedVelocities.right += childNode.velocities.right * childMass;
                rightMass += childMass;
            }
            
            // Bottom face (y=0): children 0, 1, 4, 5
            if ((childIdx & 2) == 0) // y bit is 0
            {
                aggregatedVelocities.bottom += childNode.velocities.bottom * childMass;
                bottomMass += childMass;
            }
            
            // Top face (y=1): children 2, 3, 6, 7
            if ((childIdx & 2) == 2) // y bit is 1
            {
                aggregatedVelocities.top += childNode.velocities.top * childMass;
                topMass += childMass;
            }
            
            // Front face (z=0): children 0, 1, 2, 3
            if ((childIdx & 4) == 0) // z bit is 0
            {
                aggregatedVelocities.front += childNode.velocities.front * childMass;
                frontMass += childMass;
            }
            
            // Back face (z=1): children 4, 5, 6, 7
            if ((childIdx & 4) == 4) // z bit is 1
            {
                aggregatedVelocities.back += childNode.velocities.back * childMass;
                backMass += childMass;
            }
        }
        
        // Normalize by total mass to get mass-weighted average face velocities
        float epsilon = 1e-9;
        aggregatedVelocities.left   /= max(epsilon, leftMass);
        aggregatedVelocities.right  /= max(epsilon, rightMass);
        aggregatedVelocities.bottom /= max(epsilon, bottomMass);
        aggregatedVelocities.top    /= max(epsilon, topMass);
        aggregatedVelocities.front  /= max(epsilon, frontMass);
        aggregatedVelocities.back   /= max(epsilon, backMass);

        // weightedPosition = clamp(weightedPosition, simulationBoundsMin, simulationBoundsMax);

        Node aggregatedNode;
        aggregatedNode.position = weightedPosition;
        aggregatedNode.velocity = weightedVelocity;
        aggregatedNode.velocities = aggregatedVelocities;
        aggregatedNode.layer = minSubLayer;
        aggregatedNode.mass = totalMass;
        aggregatedNode.mortonCode = nodesBuffer[uniqueStart].mortonCode;
        aggregatedNode.active = 1u; // Set last bit to 1

        nodesBuffer[uniqueStart] = aggregatedNode;

        for (uint j = 1; j < numNodesInGroup; j++)
        {
            nodesBuffer[uniqueStart + j].active = 0u; // Set last bit to 0
        }
    } else {
        for (uint j = uniqueStart; j < uniqueEnd; j++)
        {
            Node node = nodesBuffer[j];
            if (node.layer > layer) {
                nodesBuffer[j].layer = layer - 1;
            }
        }
    }
}

// Next step: handle bigger than current layer
// Do multiplier when aggregating based on layer

[numthreads(512, 1, 1)]
void findNeighbors(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];

    // Initialize neighbors to invalid index (numNodes) for all 24 slots
    uint nbBase = threadIndex * 24;
    for (uint k = 0; k < 24; k++)
    {
        neighborsBuffer[nbBase + k] = numNodes;
    }

    // all face neighbors of this node. It's bounded to 2:1 ratio
    int3 deltas[6] = {int3(-1,0,0), int3(1,0,0), int3(0,-1,0), int3(0,1,0), int3(0,0,-1), int3(0,0,1)};

    uint shift = node.layer * 3;
    uint prefix = node.mortonCode >> shift;
    uint3 coord = deinterleave(prefix);

    for (int d = 0; d < 6; d++)
    {
        int nx = (int)coord.x + deltas[d].x;
        int ny = (int)coord.y + deltas[d].y;
        int nz = (int)coord.z + deltas[d].z;
        
        // Skip if neighbor is outside the grid bounds for this layer
        uint gridDim = 1u << (10 - node.layer);
        if (nx < 0 || ny < 0 || nz < 0 || nx >= (int)gridDim || ny >= (int)gridDim || nz >= (int)gridDim)
        {
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = numNodes + 1;
            continue; // Skip this neighbor direction
        }
        
        uint3 ncoord = uint3((uint)nx, (uint)ny, (uint)nz);
        uint nPrefix = interleave(ncoord);

        // same-layer neighbor: leq prefix will fall under eq. Layer will be eq.
        // parent neighbor: leq prefix fill fall under less or equal, but layer will be +1
        // child neighbor: search geq for lower and upper bounds. Layer will be -1, operate on all 4 subnodes.

        uint target = nPrefix << shift;
        uint upper = (nPrefix + 1u) << shift; // start of next region

        // Find the last node in this region by finding first node in next region, then subtract 1
        uint idx_next = lowerBoundMorton(upper, 0, numNodes);
        uint idx_leq = (idx_next > 0) ? idx_next - 1u : 0u;

        // Skip if no valid neighbor found
        if (idx_leq >= numNodes) continue;

        Node nNode = nodesBuffer[idx_leq];
        uint idx_leq_mc = nNode.mortonCode;
        uint idx_leq_mc_prefix = idx_leq_mc >> shift;
        uint idx_leq_layer = nNode.layer;

        if (idx_leq_mc_prefix == nPrefix && idx_leq_layer == node.layer)
        {
            // same-layer neighbor
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else if ((idx_leq_mc >> (shift + 3)) == (nPrefix >> 3) && idx_leq_layer == node.layer + 1)
        {
            // parent neighbor
            neighborsBuffer[threadIndex * 24 + faceOffset(d)] = idx_leq;
        }
        else
        {
            // child neighbor path only valid if shift >= 3 (layer >= 1)
            if (shift >= 3)
            {
                uint idx_target = lowerBoundMorton(target, 0, numNodes); // low child bound
                uint idx_upper = lowerBoundMorton(upper, 0, numNodes); // high child bound
                if (idx_target < idx_upper)
                {
                    uint nPrefixShifted = nPrefix << 3;
                    int subNodesLower[4];
                    if (d == 0) { // right face
                        subNodesLower[0] = 1;
                        subNodesLower[1] = 3;
                        subNodesLower[2] = 5;
                        subNodesLower[3] = 7;
                    } else if (d == 1) { // left face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 2;
                        subNodesLower[2] = 4;
                        subNodesLower[3] = 6;
                    } else if (d == 2) { // top face
                        subNodesLower[0] = 2;
                        subNodesLower[1] = 3;
                        subNodesLower[2] = 6;
                        subNodesLower[3] = 7;
                    } else if (d == 3) { // bottom face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 1;
                        subNodesLower[2] = 4;
                        subNodesLower[3] = 5;
                    } else if (d == 4) { // back face
                        subNodesLower[0] = 4;
                        subNodesLower[1] = 5;
                        subNodesLower[2] = 6;
                        subNodesLower[3] = 7;
                    } else if (d == 5) { // front face
                        subNodesLower[0] = 0;
                        subNodesLower[1] = 1;
                        subNodesLower[2] = 2;
                        subNodesLower[3] = 3;
                    }
                    
                    for (int i = 0; i < 4; i++)
                    {
                        uint subPrefix = nPrefixShifted + subNodesLower[i];
                        uint subLower = subPrefix << (shift - 3);
                        uint subUpper = (subPrefix + 1u) << (shift - 3);
                        uint idx_sub = lowerBoundMorton(subLower, idx_target, idx_upper);
                        if (idx_sub < idx_upper)
                        {
                            Node cNode = nodesBuffer[idx_sub];
                            uint idx_sub_mc = cNode.mortonCode;
                            uint idx_sub_mc_prefix = idx_sub_mc >> (shift - 3);
                            uint idx_sub_layer = cNode.layer;
                            if (idx_sub_mc_prefix == subPrefix && idx_sub_layer == node.layer - 1)
                            {
                                neighborsBuffer[threadIndex * 24 + faceOffset(d) + i] = idx_sub;
                            }
                        }
                    }
                }
            }
        }
    }
}

[numthreads(512, 1, 1)]
void interpolateFaceVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    Node outNode = node; // Start with current velocities

    uint neighborBaseIndex = threadIndex * 24;

    for (int d = 0; d < 6; d++) {
        uint baseFaceIndex = neighborBaseIndex + d * 4;
        uint n0_idx = neighborsBuffer[baseFaceIndex]; 

        // --- 1. Check for Wall Boundary (Neumann) ---
        // If the first slot is a wall, the whole face is a wall.
        // (Assuming walls are not finer than the current node)
        if (n0_idx == numNodes + 1) {
             if (d == 0) outNode.velocities.left = 0;
             else if (d == 1) outNode.velocities.right = 0;
             else if (d == 2) outNode.velocities.bottom = 0;
             else if (d == 3) outNode.velocities.top = 0;
             else if (d == 4) outNode.velocities.front = 0;
             else outNode.velocities.back = 0;
             continue; 
        }

        // --- 2. Check for Same-Layer or Parent (Coarser) ---
        // These are single-node neighbors. They MUST be valid (< numNodes) 
        // AND have a layer >= current layer to qualify.
        bool isCoarserOrSame = false;
        if (n0_idx < numNodes) {
            Node n0 = nodesBuffer[n0_idx];
            if (n0.layer >= node.layer) {
                isCoarserOrSame = true;
                
                if (n0.layer == node.layer) {
                    // --- Same Layer Logic ---
                    if (d == 0) outNode.velocities.left = 0.5 * (node.velocities.left + n0.velocities.right);
                    else if (d == 1) outNode.velocities.right = 0.5 * (node.velocities.right + n0.velocities.left);
                    else if (d == 2) outNode.velocities.bottom = 0.5 * (node.velocities.bottom + n0.velocities.top);
                    else if (d == 3) outNode.velocities.top = 0.5 * (node.velocities.top + n0.velocities.bottom);
                    else if (d == 4) outNode.velocities.front = 0.5 * (node.velocities.front + n0.velocities.back);
                    else outNode.velocities.back = 0.5 * (node.velocities.back + n0.velocities.front);
                } 
                else { 
                    // --- Parent Logic ---
                    uint neighborD = d ^ 1;
                    uint n0BaseNeighborFaceIndex = n0_idx * 24 + neighborD * 4;

                    // average the child velocities.
                    float sumChildren = 0.0;
                    int numChildren = 0;
                    // Note: Parent's neighbors are US (and our siblings). 
                    // We look at the parent's view to ensure conservation.
                    for (int k = 0; k < 4; k++) {
                        uint child_idx = neighborsBuffer[n0BaseNeighborFaceIndex + k];
                        if (child_idx < numNodes) {
                            Node childNode = nodesBuffer[child_idx];
                            sumChildren += selectOpposingFace(childNode.velocities, neighborD);
                            numChildren += 1;
                        }
                    }
                    float childrenAverage = numChildren > 0 ? sumChildren / numChildren : 0.0;
                    float parentVal = selectOpposingFace(n0.velocities, d);
                    float mixFactor = 0.5;
                    float target = parentVal * (1.0f - mixFactor) + childrenAverage * mixFactor;
                    float offset = target - childrenAverage;

                    if (d == 0) outNode.velocities.left += offset;
                    else if (d == 1) outNode.velocities.right += offset;
                    else if (d == 2) outNode.velocities.bottom += offset;
                    else if (d == 3) outNode.velocities.top += offset;
                    else if (d == 4) outNode.velocities.front += offset;
                    else outNode.velocities.back += offset;
                }
            }
        }

        // --- 3. Mixed / Child / Open Air Logic ---
        // If it wasn't a Wall, and it wasn't a Same/Parent node, 
        // it MUST be a Child (Finer) face, partially Air, or fully Air.
        if (!isCoarserOrSame) {
            float sumChildren = 0.0;
            int validChildCount = 0;

            // Loop through ALL 4 slots. 
            // Even if slot 0 is Air, slot 1 might be valid.
            for (int k = 0; k < 4; k++) {
                uint child_idx = neighborsBuffer[baseFaceIndex + k];
                
                if (child_idx < numNodes) {
                    // VALID FLUID CHILD
                    Node childNode = nodesBuffer[child_idx];
                    sumChildren += selectOpposingFace(childNode.velocities, d);
                    validChildCount++;
                }
                // If child_idx >= numNodes, it is AIR. 
                // We simply IGNORE it. We do not add 0. We do not increment count.
                // This prevents "dragging" the velocity down.
            }

            // Only interpolate if we found at least one valid fluid neighbor.
            if (validChildCount > 0) {
                float childrenAverage = sumChildren / (float)validChildCount;
                float parentVal = selectFace(node.velocities, d);
                
                float mixFactor = 0.5;
                float newVel = parentVal * (1.0f - mixFactor) + childrenAverage * mixFactor;

                if (d == 0) outNode.velocities.left = newVel;
                else if (d == 1) outNode.velocities.right = newVel;
                else if (d == 2) outNode.velocities.bottom = newVel;
                else if (d == 3) outNode.velocities.top = newVel;
                else if (d == 4) outNode.velocities.front = newVel;
                else outNode.velocities.back = newVel;
            }
            // If validChildCount == 0, that means the entire face is Air.
            // We do nothing, preserving the original velocity (Free-slip/Open boundary).
        }
    }

    tempNodesBuffer[threadIndex] = outNode;
}

[numthreads(512, 1, 1)]
void copyFaceVelocities(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    nodesBuffer[threadIndex] = tempNodesBuffer[threadIndex];
}

[numthreads(512, 1, 1)]
void ApplyPressureGradient(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    Node outNode = node; // Start with a copy
    float p_i = pressureBuffer[threadIndex];
    float dx_i = exp2((float)node.layer);

    uint neighborBaseIndex = threadIndex * 24;

    // Loop through all 6 faces, same as findNeighbors and ApplyLaplacian
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBaseIndex + d * 4;
        uint neighbor_idx = neighborsBuffer[faceNeighborBase];
        float pressure_gradient = 0.0;
        bool isBoundary = (neighbor_idx == numNodes + 1);

        if (isBoundary) // Neumann BC: zero flux
        {
            pressure_gradient = 0.0;
            // pressure_gradient -= p_i / dx_i;
        }
        else if (neighbor_idx < numNodes && nodesBuffer[neighbor_idx].layer >= node.layer)
        {
            // Case 1: Same-layer or Parent (coarser) neighbor
            // Same layer works, not sure about parent. Probably works.
            Node nNode = nodesBuffer[neighbor_idx];
            float p_j = pressureBuffer[neighbor_idx];
            float dx_j = exp2((float)nNode.layer);
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            pressure_gradient = (p_j - p_i) / distance;
        }
        else
        {
            // Case 2: Child (finer) neighbors or Dirichlet boundary
            float sumChildren = 0.0;
            int numChildren = 0;
            for (int k = 0; k < 4; k++)
            {
                uint child_idx = neighborsBuffer[faceNeighborBase + k];
                if (child_idx < numNodes)
                {
                    Node cNode = nodesBuffer[child_idx];
                    sumChildren += pressureBuffer[child_idx];
                    numChildren += 1;
                }
            }
            float childrenAverage = numChildren > 0 ? sumChildren / numChildren : 0.0;
            float dx_j = exp2((float)node.layer - 1);
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            pressure_gradient = (childrenAverage - p_i) / distance;
        }
        
        float velocity_correction = deltaTime * pressure_gradient;

        if (d == 0) outNode.velocities.left += velocity_correction;
        else if (d == 1) outNode.velocities.right -= velocity_correction;
        else if (d == 2) outNode.velocities.bottom += velocity_correction;
        else if (d == 3) outNode.velocities.top -= velocity_correction;
        else if (d == 4) outNode.velocities.front += velocity_correction;
        else outNode.velocities.back -= velocity_correction;
    }

    tempNodesBuffer[threadIndex] = outNode;
}

[numthreads(512, 1, 1)]
void ApplyGravity(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    // Apply gravity to all face velocities consistently
    node.velocities.top -= gravity * deltaTime;
    node.velocities.bottom -= gravity * deltaTime;
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void EnforceBoundaryConditions(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node node = nodesBuffer[threadIndex];
    
    uint shift = node.layer * 3;
    uint prefix = node.mortonCode >> shift;
    uint3 coord = deinterleave(prefix);
    uint gridDim = 1u << (10 - node.layer);

    // Check X boundaries
    if (coord.x == 0) node.velocities.left = 0;
    if (coord.x == gridDim - 1) node.velocities.right = 0;
    
    // Check Y boundaries
    if (coord.y == 0) node.velocities.bottom = 0;
    if (coord.y == gridDim - 1) node.velocities.top = 0;

    // Check Z boundaries
    if (coord.z == 0) node.velocities.front = 0;
    if (coord.z == gridDim - 1) node.velocities.back = 0;
    
    nodesBuffer[threadIndex] = node;
}

[numthreads(512, 1, 1)]
void InitializePhi(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    bool isSurfaceNode = false;
    uint neighborBase = threadIndex * 24;

    // Iterate through all 6 faces
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBase + d * 4;
        bool hasFluidNeighborOnFace = false;
        bool hasAirNeighborOnFace = false;

        // Check all 4 potential neighbors on this face
        for (int k = 0; k < 4; k++)
        {
            uint neighbor_idx = neighborsBuffer[faceNeighborBase + k];

            if (neighbor_idx < numNodes || neighbor_idx == numNodes + 1)
            {
                hasFluidNeighborOnFace = true;
            }
            else if (neighbor_idx == numNodes) // "air"
            {
                hasAirNeighborOnFace = true;
            }
        }

        // A face is a *true* surface if it has at least one "air" slot
        // AND *zero* "fluid" slots. This correctly ignores padding.
        if (hasAirNeighborOnFace && !hasFluidNeighborOnFace)
        {
            isSurfaceNode = true;
            break; // Found a surface face, no need to check others
        }
    }

    if (isSurfaceNode)
    {
        phiBuffer[threadIndex] = 0.0; // Seed the surface
    }
    else
    {
        // Use a large positive number for "infinity"
        phiBuffer[threadIndex] = 1e+20; 
    }
}

[numthreads(512, 1, 1)]
void PropagatePhi(uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    if (threadIndex >= numNodes) return;

    Node selfNode = nodesBuffer[threadIndex];
    float selfSide = exp2((float)selfNode.layer);
    
    // Read this node's current phi value
    float oldPhi = phiBuffer_Read[threadIndex];
    float minPropagatedPhi = oldPhi;

    uint neighborBase = threadIndex * 24;

    // Iterate through all 6 faces
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBase + d * 4;

        // Check all 4 potential neighbors on this face (for 2:1 balance)
        for (int k = 0; k < 4; k++)
        {
            uint neighbor_idx = neighborsBuffer[faceNeighborBase + k];

            // Only check valid fluid nodes
            if (neighbor_idx < numNodes)
            {
                // Read the neighbor's phi value
                float neighborPhi = phiBuffer_Read[neighbor_idx];
                
                // Don't propagate from un-set (infinite) nodes
                if (neighborPhi < 1e+19)
                {
                    Node neighborNode = nodesBuffer[neighbor_idx];
                    float neighborSide = exp2((float)neighborNode.layer);

                    // Use the *exact* distance logic from your ApplyPressureGradient
                    // to ensure consistency.
                    float distance = max(0.5 * (selfSide + neighborSide), 1e-6);

                    // The new phi is the neighbor's distance + the distance to that neighbor
                    float propagatedPhi = neighborPhi + distance;

                    // We want the *minimum* distance from all neighbors
                    minPropagatedPhi = min(minPropagatedPhi, propagatedPhi);
                }
            }
        }
    }

    // Write the new minimum phi value
    phiBuffer[threadIndex] = minPropagatedPhi;

    // If we found a shorter path, mark the "dirty" flag.
    // This tells the C# script to run another iteration.
    if (minPropagatedPhi < oldPhi - 1e-5) // Use a small epsilon for float compare
    {
        // This is a non-atomic write, but it's fine.
        // We only care if *any* thread writes 1, not which one.
        dirtyFlagBuffer[0] = 1;
    }
}