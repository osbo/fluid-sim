// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitializeParticles
#pragma kernel UpdateParticles


// Particle struct definition
struct Particle
{
    float3 position;    // 3-component position vector
    float3 velocity;    // float face velocities
    uint layer;         // Layer units
    uint mortonCode;    // Morton code for spatial indexing
};

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

// Node struct (must match C# struct)
struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};


// 32-bit Morton code encoding function (adapted from 64-bit Swift/Metal version)
uint EncodeMorton3D(float3 pos)
{
    // Convert to uint32 and mask to 10 bits per axis (0x3FF = 1023 = 2^10-1)
    uint x = (uint)pos.x & 0x3FF;
    uint y = (uint)pos.y & 0x3FF;
    uint z = (uint)pos.z & 0x3FF;
    
    uint result = 0;
    
    // Interleave bits for 32-bit Morton code (10 bits per axis = 30 bits total)
    for (int i = 0; i < 10; i++) {
        result |= ((x & (1U << i)) << (2 * i));
        result |= ((y & (1U << i)) << (2 * i + 1));
        result |= ((z & (1U << i)) << (2 * i + 2));
    }
    
    return result;
}



// Morton helpers: interleave/deinterleave 3D (10 bits per axis)
uint3 deinterleave(uint m)
{
    uint x = 0, y = 0, z = 0;
    for (uint i = 0; i < 10; i++)
    {
        x |= ((m >> (3 * i + 0)) & 1) << i;
        y |= ((m >> (3 * i + 1)) & 1) << i;
        z |= ((m >> (3 * i + 2)) & 1) << i;
    }
    return uint3(x, y, z);
}

uint interleave(uint3 p)
{
    uint m = 0;
    for (uint i = 0; i < 10; i++)
    {
        m |= ((p.x & (1u << i)) << (2 * i + 0));
        m |= ((p.y & (1u << i)) << (2 * i + 1));
        m |= ((p.z & (1u << i)) << (2 * i + 2));
    }
    return m;
}

// Helper: given direction d, return neighbor's opposing face value
float selectOpposingFace(faceVelocities v, int d)
{
    // d: 0=left,1=right,2=bottom,3=top,4=front,5=back
    if (d == 0) return v.right;
    if (d == 1) return v.left;
    if (d == 2) return v.top;
    if (d == 3) return v.bottom;
    if (d == 4) return v.back;
    return v.front; // d == 5
}

// Helper: subtract value from the correct face on outNode for direction d
void subtractToFace(inout Node outNode, int d, float value)
{
    if (d == 0) outNode.velocities.left -= value;
    else if (d == 1) outNode.velocities.right -= value;
    else if (d == 2) outNode.velocities.bottom -= value;
    else if (d == 3) outNode.velocities.top -= value;
    else if (d == 4) outNode.velocities.front -= value;
    else outNode.velocities.back -= value; // d == 5
}

// Helper: face offset inside 24-wide neighbors block
uint faceOffset(int d)
{
    // left=0..3, right=4..7, bottom=8..11, top=12..15, front=16..19, back=20..23
    if (d == 0) return 0u;
    if (d == 1) return 4u;
    if (d == 2) return 8u;
    if (d == 3) return 12u;
    if (d == 4) return 16u;
    return 20u; // d == 5
}

// Buffer definitions
RWStructuredBuffer<Particle> particlesBuffer;
RWStructuredBuffer<Node> nodesBuffer;
RWStructuredBuffer<Node> nodesBufferOld;  // Old velocities for FLIP method
RWStructuredBuffer<uint> mortonCodesBuffer;  // Separate morton codes buffer
RWStructuredBuffer<uint> particleIndicesBuffer;  // Separate indices buffer
// nodeFlagsBuffer moved to Nodes.compute

// Parameters for particle initialization (pre-calculated on CPU)
float3 fluidInitialBoundsMin;
float3 fluidInitialBoundsMax;
float3 simulationBoundsMin;
float3 simulationBoundsMax;
float3 mortonNormalizationFactor;
float mortonMaxValue;
float gravity;
float deltaTime;
float dispersionPower; // >1 concentrates near left, <1 concentrates near right
float boundaryThreshold; // normalized u threshold near left edge considered boundary
uint minLayer;
uint numNodes;
uint numParticles;
uint maxLayer;

// Grid parameters for even particle distribution
uint3 gridDimensions;
float3 gridSpacing;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Total number of particles to initialize
uint count;

[numthreads(512,1,1)]
void InitializeParticles (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= count) return;
    
    // Initialize particle with zero values
    Particle particle;
    particle.velocity = float3(0.0, 0.0, 0.0);
    
    // Calculate grid position using morton code major order (Z, Y, X)
    // This ensures particles are distributed evenly throughout the volume
    uint gridZ = index / (gridDimensions.x * gridDimensions.y);
    uint remaining = index % (gridDimensions.x * gridDimensions.y);
    uint gridY = remaining / gridDimensions.x;
    uint gridX = remaining % gridDimensions.x;
    
    // Clamp grid position to valid range
    gridX = min(gridX, (uint)gridDimensions.x - 1);
    gridY = min(gridY, (uint)gridDimensions.y - 1);
    gridZ = min(gridZ, (uint)gridDimensions.z - 1);
    
    // Convert grid position to world position
    // Use grid spacing to position particles evenly within the bounds
    float3 gridOffset = float3(gridX, gridY, gridZ) * gridSpacing; // 3D offset

    // Base position using uniform spacing in all three axes
    float3 basePos = fluidInitialBoundsMin + gridOffset;

    // Apply power-based dispersion along X
    // u in (0,1]: cell-centered normalized coordinate across X extent
    float u = ((float)gridX + 0.5) / max(1.0, (float)gridDimensions.x);
    // Reverse density: concentrate toward the right for power > 1
    // Ensure base is positive to avoid pow() warning
    float base = max(0.0001, 1.0 - u);
    float skew = 1.0 - pow(base, max(0.0001, dispersionPower));
    float xPos = lerp(fluidInitialBoundsMin.x, fluidInitialBoundsMax.x, saturate(skew));

    // particle.position = float3(xPos, basePos.y, basePos.z);
    particle.position = float3(basePos.x, basePos.y, basePos.z);

    // Calculate center of simulation bounds
    float3 simulationCenter = (fluidInitialBoundsMin + fluidInitialBoundsMax) * 0.5;
    
    // Check if particle is within a small radius of the center
    // float2 centerOffset = float2(particle.position.x - simulationCenter.x, particle.position.y - simulationCenter.y);
    float3 centerOffset = float3(particle.position.x - simulationCenter.x, particle.position.y - (simulationCenter.y + 20), particle.position.z - simulationCenter.z);
    float distanceFromCenter = length(centerOffset);
    float centerRadius = 3; // Small radius around center for layer 0 particles
    
    // Assign layer: center particles get layer 0, boundary particles get layer 0, others get layer 11
    bool nearCenter = (distanceFromCenter <= centerRadius);
    bool onBoundary = (u > (1.0 - max(0.0, boundaryThreshold)));
    // particle.layer = (nearCenter || onBoundary) ? minLayer : 11;
    // particle.layer = onBoundary ? minLayer : 11;
    particle.layer = (nearCenter) ? minLayer : maxLayer;
    // particle.layer = 11;
    // particle.layer = 4;

    if (nearCenter) {
        particle.velocity = float3(0.0, 100.0, 0.0);
    }
    

    float3 normalizedPos = (particle.position - simulationBoundsMin) * mortonNormalizationFactor;
    normalizedPos = clamp(normalizedPos, 0.0, mortonMaxValue);
    // Generate morton code from normalized position
    particle.mortonCode = EncodeMorton3D(normalizedPos);

    // particle.layer = particle.mortonCode % 10;
    
    // Write particle to buffer
    particlesBuffer[index] = particle;
    
    // Note: nodeFlagsBuffer initialization moved to CreateNodes() in Nodes.compute
}

[numthreads(512,1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x; 
    if (index >= numParticles) return;

    Particle particle = particlesBuffer[index];

    // --- 1. Find Containing Grid Cell (Corrected Logic) ---
    bool useFallback = (numNodes == 0);
    uint nodeIndex = 0;

    if (!useFallback) {
        uint target = particle.mortonCode; 
        uint left = 0;
        uint right = numNodes; 
        
        // Binary search to find the first node with a Morton code >= particle's code
        while (left < right) {
            uint mid = left + ((right - left) >> 1); 
            if (nodesBuffer[mid].mortonCode < target) {
                left = mid + 1; 
            } else {
                right = mid; 
            }
        }

        // **THE FIX**: Check if the particle is truly outside the grid's bounds.
        // It is outside if its code is smaller than the first node's code,
        // or if the search result points past the end of the array.
        if (left == numNodes || (left == 0 && particle.mortonCode < nodesBuffer[0].mortonCode)) {
            useFallback = true;
        } else {
            // The original index calculation is correct once the fallback condition is fixed.
            // It finds the node whose Morton code is <= the particle's code.
            nodeIndex = (left > 0) ? left - 1 : 0; 
        }
    }

    if (useFallback) {
        // Fallback for particles outside the main fluid body
        particle.velocity.y -= gravity * deltaTime; 
        particle.position += particle.velocity * deltaTime;
        
        // Simplified boundary conditions for fallback particles
        if (particle.position.y <= simulationBoundsMin.y) {
             particle.position.y = simulationBoundsMin.y;
             particle.velocity.y *= -0.5; 
        }
        // ... (can add other boundary checks if needed) ...
        particle.position = clamp(particle.position, simulationBoundsMin, simulationBoundsMax); 
    } else {
        // --- Main Fluid Logic (Unchanged) ---
        Node node = nodesBuffer[nodeIndex];
        Node nodeOld = nodesBufferOld[nodeIndex]; 

        // Interpolate velocity from grid (Trilinear)
        float3 simulationSize = simulationBoundsMax - simulationBoundsMin; 
        uint cellMortonCode = node.mortonCode & ~((1u << (3 * node.layer)) - 1);
        uint3 cellGridMin = deinterleave(cellMortonCode);
        float cellGridSize = exp2((float)node.layer); 
        float3 nodeMin = simulationBoundsMin + (float3(cellGridMin) / 1023.0) * simulationSize;
        float3 nodeMax = nodeMin + (cellGridSize / 1023.0) * simulationSize; 
        float3 extent = max(nodeMax - nodeMin, 1e-6);
        float3 t = saturate((particle.position - nodeMin) / extent); 

        // Interpolate new and old velocities for FLIP
        float3 newGridVelocity; 
        newGridVelocity.x = lerp(-node.velocities.left, node.velocities.right, t.x);
        newGridVelocity.y = lerp(-node.velocities.bottom, node.velocities.top, t.y);
        newGridVelocity.z = lerp(-node.velocities.front, node.velocities.back, t.z); 
        
        float3 oldGridVelocity; 
        oldGridVelocity.x = lerp(-nodeOld.velocities.left, nodeOld.velocities.right, t.x);
        oldGridVelocity.y = lerp(-nodeOld.velocities.bottom, nodeOld.velocities.top, t.y);
        oldGridVelocity.z = lerp(-nodeOld.velocities.front, nodeOld.velocities.back, t.z); 

        // FLIP method: Calculate velocity delta and blend
        float3 grid_velocity_delta = newGridVelocity - oldGridVelocity; 
        float3 flip_velocity = particle.velocity + grid_velocity_delta; 
        float flip_ratio = 0.95f; 
        float3 newVelocity = lerp(newGridVelocity, flip_velocity, flip_ratio); 

        // Advect the particle and apply boundary conditions
        float3 newPosition = particle.position + newVelocity * deltaTime; 

        float bounceDamping = 0.5f; 
        float epsilon = 0.001f; 

        if (newPosition.x <= simulationBoundsMin.x) { newPosition.x = simulationBoundsMin.x + epsilon; newVelocity.x *= -1.0 * bounceDamping; } 
        if (newPosition.x >= simulationBoundsMax.x) { newPosition.x = simulationBoundsMax.x - epsilon; newVelocity.x *= -1.0 * bounceDamping; } 
        if (newPosition.y <= simulationBoundsMin.y) { newPosition.y = simulationBoundsMin.y + epsilon; newVelocity.y *= -1.0 * bounceDamping; } 
        if (newPosition.y >= simulationBoundsMax.y) { newPosition.y = simulationBoundsMax.y - epsilon; newVelocity.y *= -1.0 * bounceDamping; } 
        if (newPosition.z <= simulationBoundsMin.z) { newPosition.z = simulationBoundsMin.z + epsilon; newVelocity.z *= -1.0 * bounceDamping; } 
        if (newPosition.z >= simulationBoundsMax.z) { newPosition.z = simulationBoundsMax.z - epsilon; newVelocity.z *= -1.0 * bounceDamping; } 

        particle.position = newPosition; 
        particle.velocity = newVelocity;
    }

    // --- 4. Update Morton Code for Next Frame ---
    float3 normalizedPos = (particle.position - simulationBoundsMin) * mortonNormalizationFactor; 
    normalizedPos = clamp(normalizedPos, 0.0, mortonMaxValue);
    particle.mortonCode = EncodeMorton3D(normalizedPos);

    particlesBuffer[index] = particle;
}