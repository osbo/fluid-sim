// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitializeParticles
#pragma kernel AdvectParticles

// 32-bit Morton code encoding function (adapted from 64-bit Swift/Metal version)
uint EncodeMorton3D(float3 pos)
{
    // Convert to uint32 and mask to 10 bits per axis (0x3FF = 1023 = 2^10-1)
    uint x = (uint)pos.x & 0x3FF;
    uint y = (uint)pos.y & 0x3FF;
    uint z = (uint)pos.z & 0x3FF;
    
    uint result = 0;
    
    // Interleave bits for 32-bit Morton code (10 bits per axis = 30 bits total)
    for (int i = 0; i < 10; i++) {
        result |= ((x & (1U << i)) << (2 * i));
        result |= ((y & (1U << i)) << (2 * i + 1));
        result |= ((z & (1U << i)) << (2 * i + 2));
    }
    
    return result;
}

// Particle struct definition
struct Particle
{
    float3 position;    // 3-component position vector
    float3 velocity;    // float face velocities
    uint layer;         // Layer units
    uint mortonCode;    // Morton code for spatial indexing
};

// Buffer definitions
RWStructuredBuffer<Particle> particlesBuffer;
RWStructuredBuffer<uint> mortonCodesBuffer;  // Separate morton codes buffer
RWStructuredBuffer<uint> particleIndicesBuffer;  // Separate indices buffer
// nodeFlagsBuffer moved to Nodes.compute

// Parameters for particle initialization (pre-calculated on CPU)
float3 fluidInitialBoundsMin;
float3 fluidInitialBoundsMax;
float3 simulationBoundsMin;
float3 simulationBoundsMax;
float3 mortonNormalizationFactor;
float mortonMaxValue;
float gravity;
float deltaTime;
float dispersionPower; // >1 concentrates near left, <1 concentrates near right
float boundaryThreshold; // normalized u threshold near left edge considered boundary
uint initialLayer;

// Grid parameters for even particle distribution
uint3 gridDimensions;
float3 gridSpacing;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Total number of particles to initialize
uint count;

[numthreads(512,1,1)]
void InitializeParticles (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= count) return;
    
    // Initialize particle with zero values
    Particle particle;
    particle.velocity = float3(0.0, 0.0, 0.0);
    
    // Calculate grid position using morton code major order (Z, Y, X)
    // This ensures particles are distributed evenly throughout the volume
    uint gridZ = index / (gridDimensions.x * gridDimensions.y);
    uint remaining = index % (gridDimensions.x * gridDimensions.y);
    uint gridY = remaining / gridDimensions.x;
    uint gridX = remaining % gridDimensions.x;
    
    // Clamp grid position to valid range
    gridX = min(gridX, (uint)gridDimensions.x - 1);
    gridY = min(gridY, (uint)gridDimensions.y - 1);
    gridZ = min(gridZ, (uint)gridDimensions.z - 1);
    
    // Convert grid position to world position
    // Use grid spacing to position particles evenly within the bounds
    float3 gridOffset = float3(gridX, gridY, gridZ) * gridSpacing; // 3D offset

    // Base position using uniform spacing in all three axes
    float3 basePos = fluidInitialBoundsMin + gridOffset;

    // Apply power-based dispersion along X
    // u in (0,1]: cell-centered normalized coordinate across X extent
    float u = ((float)gridX + 0.5) / max(1.0, (float)gridDimensions.x);
    // Reverse density: concentrate toward the right for power > 1
    // Ensure base is positive to avoid pow() warning
    float base = max(0.0001, 1.0 - u);
    float skew = 1.0 - pow(base, max(0.0001, dispersionPower));
    float xPos = lerp(fluidInitialBoundsMin.x, fluidInitialBoundsMax.x, saturate(skew));

    // particle.position = float3(xPos, basePos.y, basePos.z);
    particle.position = float3(basePos.x, basePos.y, basePos.z);

    // Calculate center of simulation bounds
    float3 simulationCenter = (fluidInitialBoundsMin + fluidInitialBoundsMax) * 0.5;
    
    // Check if particle is within a small radius of the center
    // float2 centerOffset = float2(particle.position.x - simulationCenter.x, particle.position.y - simulationCenter.y);
    float3 centerOffset = float3(particle.position.x - simulationCenter.x, particle.position.y - simulationCenter.y, particle.position.z - simulationCenter.z);
    float distanceFromCenter = length(centerOffset);
    float centerRadius = 3; // Small radius around center for layer 0 particles
    
    // Assign layer: center particles get layer 0, boundary particles get layer 0, others get layer 11
    bool nearCenter = (distanceFromCenter <= centerRadius);
    bool onBoundary = (u > (1.0 - max(0.0, boundaryThreshold)));
    // particle.layer = (nearCenter || onBoundary) ? initialLayer : 11;
    // particle.layer = onBoundary ? initialLayer : 11;
    // particle.layer = (nearCenter) ? initialLayer : 11;
    particle.layer = 11;

    // if (nearCenter) {
    //     particle.velocity = float3(-1.0, 0, 0.0);
    // }
    
    // Generate morton code from normalized position
    // particle.mortonCode = EncodeMorton3D(normalizedPos);
    particle.mortonCode = 0;

    // particle.layer = particle.mortonCode % 10;
    
    // Write particle to buffer
    particlesBuffer[index] = particle;
    
    // Note: nodeFlagsBuffer initialization moved to CreateNodes() in Nodes.compute
}

[numthreads(512,1,1)]
void AdvectParticles (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= count) return;

    Particle particle = particlesBuffer[index];
    float3 velocity = particle.velocity;

    // Vectors point outward from the face

    // velocity.y -= gravity * deltaTime;

    float3 position = particle.position + velocity * deltaTime;
    
    // Clamp position to simulation bounds
    position.x = clamp(position.x, simulationBoundsMin.x, simulationBoundsMax.x);
    position.y = clamp(position.y, simulationBoundsMin.y, simulationBoundsMax.y);
    position.z = clamp(position.z, simulationBoundsMin.z, simulationBoundsMax.z);

    particle.position = position;
    particle.velocity = velocity;
    // particle.velocity = float3(0.0, -1.0, 0.0);

    float3 normalizedPos = (position - simulationBoundsMin) * mortonNormalizationFactor;
    normalizedPos = clamp(normalizedPos, 0.0, mortonMaxValue);

    particle.mortonCode = EncodeMorton3D(normalizedPos);

    particlesBuffer[index] = particle;
}