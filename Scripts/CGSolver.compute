#pragma kernel ApplyLaplacian
#pragma kernel Axpy // y = a*x + y
#pragma kernel Scale // y = a*y
#pragma kernel CalculateDivergence
#pragma kernel DotProduct
#pragma kernel ApplySparseG
#pragma kernel ApplySparseGT
#pragma kernel ClearBufferFloat

// Include common HLSL functions
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

// Struct definitions (must match C# structs)
struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

struct Node
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Buffers for CG solver
RWStructuredBuffer<Node> nodesBuffer;
RWStructuredBuffer<float> divergenceBuffer;
RWStructuredBuffer<uint> neighborsBuffer;
RWStructuredBuffer<float> pBuffer; // The input vector 'p'
RWStructuredBuffer<float> ApBuffer; // The output vector 'Ap'
RWStructuredBuffer<float> xBuffer;
RWStructuredBuffer<float> yBuffer;
RWStructuredBuffer<float> matrixGBuffer; // [N * 25] The Preconditioner Matrix G
RWStructuredBuffer<float> zBuffer;       // Intermediate buffer "u" and Output "z"
uint numNodes;
float a; // scalar 'a'
float deltaTime; // Time step for physics scaling

// Shared memory for dot product reduction
groupshared float s_data[512];

[numthreads(512, 1, 1)]
void CalculateDivergence(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    faceVelocities v = node.velocities;

    // Calculate Net Flux of Velocity
    // Flux = Sum(Velocity * FaceArea)
    float dx = exp2((float)node.layer);
    float faceArea = dx * dx;
    
    // Net flux leaving the cell
    float netFlux = (v.right - v.left + v.top - v.bottom + v.back - v.front) * faceArea;
    
    // We solve Ap = b. If A is negative Laplacian, b should be negative Divergence.
    float outVal = -netFlux;
    
    if (!isfinite(outVal)) outVal = 0.0;
    divergenceBuffer[i] = outVal;
}

[numthreads(512, 1, 1)]
void ApplyLaplacian(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    float p_i = pBuffer[i];
    float laplacian_p = 0.0;

    // Guard against NaN values in input
    if (!isfinite(p_i)) p_i = 0.0;

    float dx_i = exp2((float)node.layer);
    if (!isfinite(dx_i)) dx_i = 1e-6;
    uint neighborBaseIndex = i * 24;

    // Loop over all 6 faces of the node
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBaseIndex + d * 4;
        uint neighbor_idx = neighborsBuffer[faceNeighborBase]; // first slot: same/parent layer

        // Check the three distinct neighbor cases

        // Case 1: True Boundary (Neumann BC, neighbor_idx == numNodes + 1 )
        if (neighbor_idx == numNodes + 1)
        {
            // Neumann BC means zero flux (dp/dn = 0).
            // The flux contribution is 0.
            laplacian_p += 0.0;
        }
        // Case 2: Same-layer or Parent (coarser) neighbor
        else if (neighbor_idx < numNodes && nodesBuffer[neighbor_idx].layer >= node.layer)
        {
            Node nNode = nodesBuffer[neighbor_idx];
            float p_j = pBuffer[neighbor_idx];
            
            float dx_j = exp2((float)nNode.layer);
            
            // Distance between cell centers
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            
            // Face area is the area of cell i's face (dx_i^2)
            float a_shared = dx_i * dx_i;
            
            // Weight: area divided by distance
            float w = a_shared / distance;
            
            float contribution = w * (p_j - p_i);
            
            laplacian_p += contribution;
        }
        else
        {
            // Case 3 or 4: Child (finer) neighbors or Dirichlet boundary
            // The face of cell i is subdivided into 4 child cells
            // Each child occupies 1/4 of the face area
            float faceArea = dx_i * dx_i;
            float childFaceArea = faceArea / 4.0; // Each child occupies 1/4 of the face
            
            for (int k = 0; k < 4; k++)
            {
                uint child_idx = neighborsBuffer[faceNeighborBase + k];
                // Case 3: Child (finer) neighbor
                if (child_idx < numNodes)
                {
                    Node cNode = nodesBuffer[child_idx];
                    float p_k = pBuffer[child_idx];
                    float dx_k = exp2((float)cNode.layer);
                    
                    // Distance between cell i center and child cell k center
                    float distance = max(0.5 * (dx_i + dx_k), 1e-6);
                    
                    // Weight: child's portion of face area divided by distance
                    float w = childFaceArea / distance;
                    
                    float contribution = w * (p_k - p_i);
                    laplacian_p += contribution;
                }
                // Case 4: Dirichlet boundary
                else if (child_idx == numNodes)
                {
                    float dx_k = dx_i * 0.5;
                    float distance = max(0.5 * (dx_i + dx_k), 1e-6);
                    
                    // Weight: child's portion of face area divided by distance
                    float w = childFaceArea / distance;
                    
                    float contribution = w * (-p_i); // No pressure over the boundary
                    laplacian_p += contribution;
                }
            }

            // float sumChildren = 0.0;
            // int numChildren = 0;
            // for (int k = 0; k < 4; k++) {
            //     uint child_idx = neighborsBuffer[faceNeighborBase + k];
            //     if (child_idx < numNodes) {
            //         Node cNode = nodesBuffer[child_idx];
            //         float p_k = pBuffer[child_idx];
            //         sumChildren += p_k;
            //         numChildren += 1;
            //     }
            // }

            // // float childrenAverage = numChildren > 0 ? sumChildren / numChildren : 0.0;
            // float childrenAverage = sumChildren / 4.0;
            // float dx_j = exp2((float)node.layer - 1);
            // float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            // float w = childFaceArea / distance;
            // float contribution = w * (childrenAverage - p_i);
            // laplacian_p += contribution;
        }
    }

    // --- Return Net Flux (not volume-normalized) ---
    // REMOVE division by volume_i
    // float volume_i = dx_i * dx_i * dx_i; <-- Delete or comment out
    // float outVal = laplacian_p / max(volume_i, 1e-9); <-- Delete this
    
    // KEEP this (assuming negative sign is desired for the operator)
    float outVal = -laplacian_p; 
    
    // Apply time step if needed, though typically handled in the update step
    outVal *= deltaTime; 

    if (!isfinite(outVal)) outVal = 0.0;
    ApBuffer[i] = outVal;
}

[numthreads(512, 1, 1)]
void Scale(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= numNodes) return;
    
    float y_val = yBuffer[i];
    
    float result = a * y_val;
    
    yBuffer[i] = result;
}

[numthreads(512, 1, 1)]
void Axpy(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= numNodes) return;
    
    float x_val = xBuffer[i];
    float y_val = yBuffer[i];
    
    float result = a * x_val + y_val;
    
    yBuffer[i] = result;
}

// For Dot Product (a simple, multi-pass reduction)
[numthreads(512, 1, 1)]
void DotProduct(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID, uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    uint li = Gtid.x;

    float x_val = (i < numNodes) ? xBuffer[i] : 0.0;
    float y_val = (i < numNodes) ? yBuffer[i] : 0.0;
    
    // Guard against NaN values
    if (!isfinite(x_val)) x_val = 0.0;
    if (!isfinite(y_val)) y_val = 0.0;
    
    float product = x_val * y_val;
    if (!isfinite(product)) product = 0.0;
    
    s_data[li] = product;
    GroupMemoryBarrierWithGroupSync();

    for (uint s = 256; s > 0; s >>= 1) {
        if (li < s) {
            float sum = s_data[li] + s_data[li + s];
            if (!isfinite(sum)) sum = 0.0;
            s_data[li] = sum;
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (li == 0) {
        float result = s_data[0];
        if (!isfinite(result)) result = 0.0;
        divergenceBuffer[Gid.x] = result;
    }
}

// --------------------------------------------------------------------------------
// NEURAL PRECONDITIONER KERNELS
// Implements M^-1 * r approx (G * G^T + eps * I) * r
// --------------------------------------------------------------------------------

// OPTIMIZED GATHER KERNEL (Replaces Scatter)
// Computes u = G^T * r
// Formula: u_i = G_ii * r_i + Sum_{k in neighbors} ( G_ki * r_k )
// Complexity: O(24Ã—24) per node = O(1) relative to N
[numthreads(512, 1, 1)]
void ApplySparseGT(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    float r_i = xBuffer[i];
    if (!isfinite(r_i)) r_i = 0.0;
    
    uint g_base_i = i * 25;
    
    // 1. Diagonal Contribution (G_ii * r_i)
    float g_diag = matrixGBuffer[g_base_i];
    if (!isfinite(g_diag)) g_diag = 0.0;
    float sum = g_diag * r_i;

    // 2. Off-Diagonal Contribution
    // Iterate my neighbors 'k'. If I am connected to k, k is connected to me.
    // We need to find G_ki (which is stored at node k).
    uint n_base_i = i * 24;
    
    for (int n = 0; n < 24; n++)
    {
        uint k = neighborsBuffer[n_base_i + n];
        
        // Valid neighbor?
        if (k < numNodes)
        {
            float r_k = xBuffer[k];
            if (!isfinite(r_k)) r_k = 0.0;
            
            // Now we need G_ki. This is stored in matrixGBuffer at index k.
            // But which neighbor slot of k corresponds to 'i'?
            // We search k's neighbors to find 'i'.
            uint n_base_k = k * 24;
            uint g_base_k = k * 25;
            
            // Search k's 24 neighbors (Small constant loop, fast in cache)
            for (int slot = 0; slot < 24; slot++)
            {
                if (neighborsBuffer[n_base_k + slot] == i)
                {
                    // Found it! G_ki is at slot+1 (0 is diagonal)
                    float g_ki = matrixGBuffer[g_base_k + 1 + slot];
                    if (!isfinite(g_ki)) g_ki = 0.0;
                    sum += g_ki * r_k;
                    break; // Optimization: Stop once found
                }
            }
        }
    }

    if (!isfinite(sum)) sum = 0.0;
    zBuffer[i] = sum;
}

// KERNEL 2: Gather (z = G * u)
// Each node 'i' reads 'u' from neighbors 'j' and GATHERS results
// Also adds epsilon regularization: z += eps * r
[numthreads(512, 1, 1)]
void ApplySparseG(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    // xBuffer here holds the original 'r' (for epsilon add)
    // zBuffer holds 'u' (input from GT step)
    // We write result back to yBuffer (which is 'z' in PCG)

    float u_val = zBuffer[i];
    if (!isfinite(u_val)) u_val = 0.0;
    
    float z_sum = 0.0;

    uint g_base = i * 25;
    uint n_base = i * 24;

    // 1. Diagonal
    float g_diag = matrixGBuffer[g_base];
    if (!isfinite(g_diag)) g_diag = 0.0;
    z_sum += u_val * g_diag;

    // 2. Neighbors (Gather)
    for(int k=0; k<24; k++)
    {
        uint n_idx = neighborsBuffer[n_base + k];
        if(n_idx < numNodes)
        {
            float g_coeff = matrixGBuffer[g_base + 1 + k];
            if (!isfinite(g_coeff)) g_coeff = 0.0;
            
            float u_neighbor = zBuffer[n_idx];
            if (!isfinite(u_neighbor)) u_neighbor = 0.0;
            
            z_sum += g_coeff * u_neighbor;
        }
    }
    
    // 3. Epsilon Regularization (z += 1e-4 * r)
    // Note: In PCG, we often reuse buffers. Ensure 'xBuffer' is bound to 'r'.
    float r_val = xBuffer[i];
    if (!isfinite(r_val)) r_val = 0.0;
    z_sum += 1e-4 * r_val;

    if (!isfinite(z_sum)) z_sum = 0.0;
    yBuffer[i] = z_sum;
}

// KERNEL 3: Clear Buffer (Helper to zero out zBuffer before Scatter)
[numthreads(512, 1, 1)]
void ClearBufferFloat(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i < numNodes) zBuffer[i] = 0.0;
}