#pragma kernel ApplyLaplacian
#pragma kernel Axpy // y = a*x + y
#pragma kernel Scale // y = a*y
#pragma kernel CalculateDivergence
#pragma kernel DotProduct

// Include common HLSL functions
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

// Struct definitions (must match C# structs)
struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

struct Node
{
    float3 position;    // 12 bytes
    float3 velocity;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Buffers for CG solver
RWStructuredBuffer<Node> nodesBuffer;
RWStructuredBuffer<float> divergenceBuffer;
RWStructuredBuffer<uint> neighborsBuffer;
RWStructuredBuffer<float> pBuffer; // The input vector 'p'
RWStructuredBuffer<float> ApBuffer; // The output vector 'Ap'
RWStructuredBuffer<float> xBuffer;
RWStructuredBuffer<float> yBuffer;
uint numNodes;
float a; // scalar 'a'
float deltaTime; // Time step for physics scaling

// Shared memory for dot product reduction
groupshared float s_data[512];

[numthreads(512, 1, 1)]
void CalculateDivergence(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    faceVelocities v = node.velocities;

    // This is the sum of (v_out - v_in) for all faces
    float divergence_flux_sum = v.right - v.left + v.top - v.bottom + v.back - v.front;
    
    float dx = exp2((float)node.layer);
    if (!isfinite(dx) || dx < 1e-6) dx = 1e-6;

    // This is b = (dx^2 / dt) * (sum of fluxes)
    float b_val = (dx * dx / max(deltaTime, 1e-9)) * divergence_flux_sum;

    // We are solving A'p = b'
    // A' = -L
    // b' = -b
    float outVal = -b_val;
    
    if (!isfinite(outVal)) outVal = 0.0;
    divergenceBuffer[i] = outVal; // This buffer is now b'
}

[numthreads(512, 1, 1)]
void ApplyLaplacian(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    float p_i = pBuffer[i];
    float laplacian_p = 0.0;
    if (!isfinite(p_i)) p_i = 0.0;

    float dx_i = exp2((float)node.layer);
    if (!isfinite(dx_i)) dx_i = 1e-6;
    uint neighborBaseIndex = i * 24;

    // Loop over all 6 faces of the node
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBaseIndex + d * 4;
        uint neighbor_idx = neighborsBuffer[faceNeighborBase]; // first slot: same/parent layer

        // --- NEW BOUNDARY LOGIC ---
        bool isTrueBoundary = (neighbor_idx == numNodes + 1);
        bool isFreeSpace = (neighbor_idx == numNodes);
        bool isFluidNeighbor = (neighbor_idx < numNodes);
        // --- END NEW LOGIC ---

        if (isTrueBoundary)
        {
            // Case 0: True Solid Wall (Neumann, dp/dn = 0)
            // We do nothing, contribution is 0.
            // This is correct.
        }
        else if (isFreeSpace)
        {
            // Case 1: Free Space (Dirichlet, p = 0)
            // We calculate flux from p_i to p_j (which is 0)
            float distance = max(0.5 * dx_i, 1e-6); // Distance from cell center to face
            float a_shared = dx_i * dx_i;           // Area of the face
            if (!isfinite(a_shared)) a_shared = 1e-12;
            
            float w = a_shared / distance;
            if (!isfinite(w)) w = 0.0;
            
            float contribution = w * (0.0 - p_i); // p_j = 0
            if (!isfinite(contribution)) contribution = 0.0;
            
            laplacian_p += contribution;
        }
        else if (isFluidNeighbor && nodesBuffer[neighbor_idx].layer >= node.layer)
        {
            // Case 2: Same-layer or Parent (coarser) fluid neighbor
            // (This is your original logic, which is correct)
            Node nNode = nodesBuffer[neighbor_idx];
            float p_j = pBuffer[neighbor_idx];
            
            if (!isfinite(p_j)) p_j = 0.0;
            float dx_j = exp2((float)nNode.layer);
            if (!isfinite(dx_j)) dx_j = 1e-6;
            
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            if (!isfinite(distance)) distance = 1e-6;
            
            float a_shared = min(dx_i, dx_j) * min(dx_i, dx_j);
            if (!isfinite(a_shared)) a_shared = 1e-12;
            float w = a_shared / distance;
            if (!isfinite(w)) w = 0.0;
            
            float contribution = w * (p_j - p_i);
            if (!isfinite(contribution)) contribution = 0.0;
            
            laplacian_p += contribution;
        }
        else if (isFluidNeighbor) // Must be a Child (finer) fluid neighbor
        {
            // Case 3: Child (finer) neighbors.
            // --- MODIFIED CHILD LOOP ---
            float avg_p_children = 0.0;
            uint childCount = 0; // Count of all non-solid-wall children
            float dx_c_avg = 0.0;
            
            for (int k = 0; k < 4; k++)
            {
                uint child_idx = neighborsBuffer[faceNeighborBase + k];

                if (child_idx == numNodes + 1)
                {
                    // This child is a solid wall, skip it (Neumann)
                    continue;
                }

                // Child is either fluid or free space, count it
                childCount++;
                
                if (child_idx < numNodes) // It's fluid
                {
                    avg_p_children += pBuffer[child_idx];
                    dx_c_avg += exp2((float)nodesBuffer[child_idx].layer);
                }
                else // It's free space (child_idx == numNodes)
                {
                    // Pressure is 0, so add 0 to avg_p_children (a no-op)
                    // But we still need its size for the average distance
                    dx_c_avg += exp2((float)node.layer - 1.0); // Child layer is parent - 1
                }
            }

            if (childCount > 0)
            {
                avg_p_children /= (float)childCount;
                dx_c_avg /= (float)childCount;

                float p_j = avg_p_children;
                if (!isfinite(p_j)) p_j = 0.0;

                float distance = max(0.5 * (dx_i + dx_c_avg), 1e-6);
                if (!isfinite(distance)) distance = 1e-6;
                float a_shared = dx_i * dx_i; // Area of the coarse face
                if (!isfinite(a_shared)) a_shared = 1e-12;

                float w = a_shared / distance;
                if (!isfinite(w)) w = 0.0;
                float contribution = w * (p_j - p_i);
                if (!isfinite(contribution)) contribution = 0.0;
                
                laplacian_p += contribution;
            }
            // If childCount is 0, all 4 children are solid walls.
            // We do nothing (Neumann).
            // --- END MODIFIED CHILD LOOP ---
        }
    }

    // (Rest of the function is unchanged)
    float outVal = -laplacian_p;

    if (!isfinite(outVal)) outVal = 0.0;
    ApBuffer[i] = outVal;
}

[numthreads(512, 1, 1)]
void Axpy(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= numNodes) return;
    
    float x_val = xBuffer[i];
    float y_val = yBuffer[i];
    
    // Guard against NaN values
    if (!isfinite(x_val)) x_val = 0.0;
    if (!isfinite(y_val)) y_val = 0.0;
    if (!isfinite(a)) a = 0.0;
    
    float result = a * x_val + y_val;
    if (!isfinite(result)) result = 0.0;
    
    yBuffer[i] = result;
}

[numthreads(512, 1, 1)]
void Scale(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= numNodes) return;
    
    float y_val = yBuffer[i];
    if (!isfinite(y_val)) y_val = 0.0;
    if (!isfinite(a)) a = 0.0;
    
    float result = a * y_val;
    if (!isfinite(result)) result = 0.0;
    
    yBuffer[i] = result;
}

// For Dot Product (a simple, multi-pass reduction)
[numthreads(512, 1, 1)]
void DotProduct(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID, uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    uint li = Gtid.x;

    float x_val = (i < numNodes) ? xBuffer[i] : 0.0;
    float y_val = (i < numNodes) ? yBuffer[i] : 0.0;
    
    // Guard against NaN values
    if (!isfinite(x_val)) x_val = 0.0;
    if (!isfinite(y_val)) y_val = 0.0;
    
    float product = x_val * y_val;
    if (!isfinite(product)) product = 0.0;
    
    s_data[li] = product;
    GroupMemoryBarrierWithGroupSync();

    for (uint s = 256; s > 0; s >>= 1) {
        if (li < s) {
            float sum = s_data[li] + s_data[li + s];
            if (!isfinite(sum)) sum = 0.0;
            s_data[li] = sum;
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (li == 0) {
        float result = s_data[0];
        if (!isfinite(result)) result = 0.0;
        divergenceBuffer[Gid.x] = result;
    }
}