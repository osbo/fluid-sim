#pragma kernel CalculateDivergence
#pragma kernel ApplyLaplacian
#pragma kernel Axpy // y = a*x + y
#pragma kernel DotProduct

// Include common HLSL functions
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

// Struct definitions (must match C# structs)
struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities;    // 24 bytes
    float mass;          // 4 bytes
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Buffers for CG solver
RWStructuredBuffer<Node> nodesBuffer;
RWStructuredBuffer<float> divergenceBuffer;
RWStructuredBuffer<uint> neighborsBuffer;
RWStructuredBuffer<float> pBuffer; // The input vector 'p'
RWStructuredBuffer<float> ApBuffer; // The output vector 'Ap'
RWStructuredBuffer<float> xBuffer;
RWStructuredBuffer<float> yBuffer;
uint numNodes;
float maxDetailCellSize; // Smallest cell size in the simulation
float a; // scalar 'a'
float deltaTime; // Time step for physics scaling

// Shared memory for dot product reduction
groupshared float s_data[512];

[numthreads(512, 1, 1)]
void CalculateDivergence(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    faceVelocities v = node.velocities;

    float divergence = v.right - v.left + v.top - v.bottom + v.back - v.front;
    float dx = max(maxDetailCellSize * exp2((float)node.layer), 1e-6);
    float outVal = -divergence / dx;
    if (!isfinite(outVal)) outVal = 0.0;
    divergenceBuffer[i] = outVal;
}

[numthreads(512, 1, 1)]
void ApplyLaplacian(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= numNodes) return;

    Node node = nodesBuffer[i];
    float p_i = pBuffer[i];
    float laplacian_p = 0.0;

    float dx_i = max(maxDetailCellSize * exp2((float)node.layer), 1e-6);
    uint neighborBaseIndex = i * 24;

    // Loop over all 6 faces of the node
    for (int d = 0; d < 6; d++)
    {
        uint faceNeighborBase = neighborBaseIndex + d * 4;
        uint neighbor_idx = neighborsBuffer[faceNeighborBase]; // first slot: same/parent layer
        bool isBoundary = (neighbor_idx >= numNodes);

        if (!isBoundary && nodesBuffer[neighbor_idx].layer >= node.layer)
        {
            // Same-layer or Parent (coarser) neighbor
            Node nNode = nodesBuffer[neighbor_idx];
            float p_j = pBuffer[neighbor_idx];
            float dx_j = max(maxDetailCellSize * exp2((float)nNode.layer), 1e-6);
            float distance = max(0.5 * (dx_i + dx_j), 1e-6);
            float a_shared = min(dx_i, dx_j) * min(dx_i, dx_j);
            float w = a_shared / distance;
            laplacian_p += w * (p_j - p_i);
        }
        else if (!isBoundary)
        {
            // Child (finer) neighbors (up to 4 per face)
            for (int k = 0; k < 4; k++)
            {
                uint child_idx = neighborsBuffer[faceNeighborBase + k];
                if (child_idx < numNodes)
                {
                    Node cNode = nodesBuffer[child_idx];
                    float p_c = pBuffer[child_idx];
                    float dx_c = max(maxDetailCellSize * exp2((float)cNode.layer), 1e-6);
                    float distance = max(0.5 * (dx_i + dx_c), 1e-6);
                    float a_shared = dx_c * dx_c; // child face area
                    float w = a_shared / distance;
                    laplacian_p += w * (p_c - p_i);
                }
            }
        }
        // If isBoundary, contribute nothing (Neumann BC)
    }

    // --- START OF FIX ---
    // The previous `laplacian_p` is Σ w*(p_j - p_i).
    // We need to compute Ap = -Δt * (1/V) * Σ w*(p_i - p_j)
    // This is equivalent to Ap = Δt * (1/V) * Σ w*(p_j - p_i)

    float volume_i = dx_i * dx_i * dx_i;
    float outVal = laplacian_p / max(volume_i, 1e-9); // This is (∇²p)_i
    outVal *= deltaTime; // This is (Δt * ∇²p)_i
    
    // We are solving -Δt∇²p, so we need one final sign flip.
    // However, your C# loop computes alpha = r_dot_r / p_dot_Ap, and your original
    // Ap was -laplacian_p, so your code implicitly expects A to be positive definite.
    // My math says Ap = Δt * ∇²p. To make it PD, we need Ap = -Δt * ∇²p.
    // This is -deltaTime * (laplacian_p / volume).
    
    outVal = -outVal;
    // --- END OF FIX ---

    if (!isfinite(outVal)) outVal = 0.0;
    ApBuffer[i] = outVal;
}

[numthreads(512, 1, 1)]
void Axpy(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if (i >= numNodes) return;
    yBuffer[i] = a * xBuffer[i] + yBuffer[i];
}

// For Dot Product (a simple, multi-pass reduction)
[numthreads(512, 1, 1)]
void DotProduct(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID, uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    uint li = Gtid.x;

    s_data[li] = (i < numNodes) ? xBuffer[i] * yBuffer[i] : 0;
    GroupMemoryBarrierWithGroupSync();

    for (uint s = 256; s > 0; s >>= 1) {
        if (li < s) {
            s_data[li] += s_data[li + s];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (li == 0) {
        divergenceBuffer[Gid.x] = s_data[0];
    }
}