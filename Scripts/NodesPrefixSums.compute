#pragma kernel markUniqueParticles
#pragma kernel markUniquesPrefix
#pragma kernel markActiveNodes
#pragma kernel markUniquesPrefix
#pragma kernel prefixSum
#pragma kernel prefixFixup
#pragma kernel scatterUniques
#pragma kernel scatterActives
#pragma kernel writeUniqueCount
#pragma kernel writeNodeCount
#pragma kernel clearUniqueBuffers
#pragma kernel clearActiveBuffers
#pragma kernel copyNodes

#define SCAN_BLOCKSIZE 512

struct Particle
{
    float3 position;    // 3-component position vector
    float3 velocity;    // float face velocities
    uint layer;         // Layer units
    uint mortonCode;    // Morton code for spatial indexing
};

struct faceVelocities
{
    float left;
    float right;
    float bottom;
    float top;
    float front;
    float back;
};

struct Node
{
    float3 position;    // 12 bytes
    faceVelocities velocities; // 24 bytes (6 floats)
    uint layer;         // 4 bytes
    uint mortonCode;    // 4 bytes
    uint active;        // 4 bytes
};

// Buffers
RWStructuredBuffer<Particle> sortedParticles;      // input: sorted particles
RWStructuredBuffer<Node> nodesBuffer;             // input: sorted nodes
RWStructuredBuffer<Node> tempNodesBuffer;         // temp: nodes buffer

RWStructuredBuffer<uint> indicators;             // temp: e (0/1) indicators
RWStructuredBuffer<uint> prefixSums;             // temp: f (exclusive scan)
RWStructuredBuffer<uint> aux;                    // temp: per-block sums
RWStructuredBuffer<uint> aux2;                   // temp: scanned per-block sums

RWStructuredBuffer<uint> uniqueIndices;          // output: indices of first occurrence of indicators
RWStructuredBuffer<uint> uniqueCount;            // output: [0] = number of indicators
RWStructuredBuffer<uint> nodeCount;            // output: [0] = number of indicators

uint len;                                        // total number of items
uint prefixBits;                                 // number of bits to shift right for prefix comparison

// groupshared for scan
groupshared uint scan_array[SCAN_BLOCKSIZE * 2];
groupshared uint morton_codes[SCAN_BLOCKSIZE];

[numthreads(512, 1, 1)]
void markUniqueParticles(uint3 id : SV_DispatchThreadID, uint3 Gtid : SV_GroupThreadID)
{
    uint i = id.x;
    uint local_i = Gtid.x;

    if (i < len)
    {
        // Load morton code into shared memory
        morton_codes[local_i] = sortedParticles[i].mortonCode >> prefixBits;
    }
    
    GroupMemoryBarrierWithGroupSync();

    if (i < len)
    {
        uint isUnique = 0;
        if (i == 0) {
            isUnique = 1;
        } else {
            uint prev_code;
            if (local_i > 0) {
                prev_code = morton_codes[local_i - 1];
            } else {
                // First thread in the block reads from global memory
                prev_code = sortedParticles[i - 1].mortonCode >> prefixBits;
            }
            
            uint curr_code = morton_codes[local_i];
            isUnique = (curr_code != prev_code) ? 1u : 0u;
        }

        indicators[i] = isUnique;
    }
}

[numthreads(512, 1, 1)]
void markUniquesPrefix(uint3 id : SV_DispatchThreadID, uint3 Gtid : SV_GroupThreadID)
{
    uint i = id.x;
    uint local_i = Gtid.x;

    if (i < len)
    {
        // Load morton code into shared memory
        morton_codes[local_i] = nodesBuffer[i].mortonCode >> prefixBits;
    }
    
    GroupMemoryBarrierWithGroupSync();

    if (i < len)
    {
        uint isUnique = 0;
        if (i == 0) {
            isUnique = 1;
        } else {
            uint prev_code;
            if (local_i > 0) {
                prev_code = morton_codes[local_i - 1];
            } else {
                // First thread in the block reads from global memory
                prev_code = nodesBuffer[i - 1].mortonCode >> prefixBits;
            }
            
            uint curr_code = morton_codes[local_i];
            isUnique = (curr_code != prev_code) ? 1u : 0u;
        }

        indicators[i] = isUnique;
    }
}

[numthreads(512, 1, 1)]
void markActiveNodes(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    indicators[i] = nodesBuffer[i].active & 1u; // Check last bit
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixSum(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint t1 = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint t2 = t1 + SCAN_BLOCKSIZE;

    // Load inputs
    scan_array[threadIdx] = (t1 < len) ? indicators[t1] : 0u;
    scan_array[threadIdx + SCAN_BLOCKSIZE] = (t2 < len) ? indicators[t2] : 0u;
    GroupMemoryBarrierWithGroupSync();

    // Upsweep
    for (uint s1 = 1; s1 <= SCAN_BLOCKSIZE; s1 <<= 1) {
        uint index = (threadIdx + 1) * s1 * 2 - 1;
        if (index < 2 * SCAN_BLOCKSIZE)
            scan_array[index] += scan_array[index - s1];
        GroupMemoryBarrierWithGroupSync();
    }

    // Downsweep
    for (uint s2 = SCAN_BLOCKSIZE >> 1; s2 > 0; s2 >>= 1) {
        uint index = (threadIdx + 1) * s2 * 2 - 1;
        if (index + s2 < 2 * SCAN_BLOCKSIZE)
            scan_array[index + s2] += scan_array[index];
        GroupMemoryBarrierWithGroupSync();
    }
    GroupMemoryBarrierWithGroupSync();

    // Write exclusive results (shift right by 1 within each block)
    if (t1 < len) {
        prefixSums[t1] = (threadIdx == 0) ? 0u : scan_array[threadIdx - 1];
    }
    if (t2 < len) {
        uint idx = threadIdx + SCAN_BLOCKSIZE - 1;
        prefixSums[t2] = scan_array[idx];
    }
    if (threadIdx == 0) {
        aux[blockIdx] = scan_array[2 * SCAN_BLOCKSIZE - 1];
    }
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixFixup(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint start = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint block_sum = aux2[blockIdx];

    if (start < len)                    prefixSums[start] += block_sum;
    if (start + SCAN_BLOCKSIZE < len)   prefixSums[start + SCAN_BLOCKSIZE] += block_sum;
}

[numthreads(512, 1, 1)]
void scatterUniques(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    if (indicators[i] == 1u) {
        uint dst = prefixSums[i];
        uniqueIndices[dst] = i;
    }
}

[numthreads(512, 1, 1)]
void scatterActives(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    if (indicators[i] == 1u) {
        uint dst = prefixSums[i];
        tempNodesBuffer[dst] = nodesBuffer[i];
    }
}

[numthreads(512, 1, 1)]
void copyNodes(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;
    nodesBuffer[i] = tempNodesBuffer[i];
}

[numthreads(1, 1, 1)]
void writeUniqueCount(uint3 id : SV_DispatchThreadID)
{
    if (len == 0) { uniqueCount[0] = 0; return; }
    uint last = len - 1;
    uniqueCount[0] = prefixSums[last] + indicators[last];
}

[numthreads(1, 1, 1)]
void writeNodeCount(uint3 id : SV_DispatchThreadID)
{
    if (len == 0) { nodeCount[0] = 0; return; }
    uint last = len - 1;
    nodeCount[0] = prefixSums[last] + indicators[last];
}

[numthreads(512, 1, 1)]
void clearUniqueBuffers(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    indicators[i] = 0;
    uniqueIndices[i] = 0;
}

[numthreads(512, 1, 1)]
void clearActiveBuffers(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    indicators[i] = 0;
}