#pragma kernel markUniques
#pragma kernel markUniquesPrefix
#pragma kernel markActiveNodes
#pragma kernel markActiveUniquesPrefix
#pragma kernel prefixSum
#pragma kernel prefixFixup
#pragma kernel scatterUniques
#pragma kernel scatterActives
#pragma kernel writeUniqueCount
#pragma kernel writeActiveCount

#define SCAN_BLOCKSIZE 512

// Buffers
RWStructuredBuffer<uint> sortedMortonCodes;      // input: sorted morton codes
RWStructuredBuffer<uint> sortedIndices;          // input: sorted particle indices (same order as codes)
RWStructuredBuffer<uint> nodeFlagsBuffer;        // input: node flags

RWStructuredBuffer<uint> indicators;             // temp: e (0/1) indicators
RWStructuredBuffer<uint> prefixSums;             // temp: f (exclusive scan)
RWStructuredBuffer<uint> aux;                    // temp: per-block sums
RWStructuredBuffer<uint> aux2;                   // temp: scanned per-block sums

RWStructuredBuffer<uint> uniqueIndices;          // output: indices of first occurrence of indicators
RWStructuredBuffer<uint> activeIndices;          // output: indices of first occurrence of indicators
RWStructuredBuffer<uint> uniqueCount;            // output: [0] = number of indicators
RWStructuredBuffer<uint> activeCount;            // output: [0] = number of indicators

uint len;                                        // total number of items
uint prefixBits;                                 // number of bits to shift right for prefix comparison

// groupshared for scan
groupshared uint scan_array[SCAN_BLOCKSIZE * 2];

[numthreads(512, 1, 1)]
void markUniques(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    uint isUnique = 0;
    if (i == 0) {
        isUnique = 1;
    } else {
        uint curr = sortedMortonCodes[i];
        uint prev = sortedMortonCodes[i - 1];
        isUnique = (curr != prev) ? 1u : 0u;
    }

    indicators[i] = isUnique;
}

[numthreads(512, 1, 1)]
void markUniquesPrefix(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    uint isUnique = 0;
    if (i == 0) {
        isUnique = 1;
    } else {
        uint curr = sortedMortonCodes[i] >> prefixBits;
        uint prev = sortedMortonCodes[i - 1] >> prefixBits;
        isUnique = (curr != prev) ? 1u : 0u;
    }

    indicators[i] = isUnique;
}

// Marks unique prefixes within the active subset indexed by activeIndices
[numthreads(512, 1, 1)]
void markActiveUniquesPrefix(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    uint isUnique = 0;
    if (i == 0) {
        isUnique = 1;
    } else {
        uint curr = sortedMortonCodes[activeIndices[i]] >> prefixBits;
        uint prev = sortedMortonCodes[activeIndices[i - 1]] >> prefixBits;
        isUnique = (curr != prev) ? 1u : 0u;
    }

    indicators[i] = isUnique;
}

[numthreads(512, 1, 1)]
void markActiveNodes(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    indicators[i] = nodeFlagsBuffer[i] & 1u;
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixSum(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint t1 = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint t2 = t1 + SCAN_BLOCKSIZE;

    // Load inputs
    scan_array[threadIdx] = (t1 < len) ? indicators[t1] : 0u;
    scan_array[threadIdx + SCAN_BLOCKSIZE] = (t2 < len) ? indicators[t2] : 0u;
    GroupMemoryBarrierWithGroupSync();

    // Upsweep
    for (uint s1 = 1; s1 <= SCAN_BLOCKSIZE; s1 <<= 1) {
        uint index = (threadIdx + 1) * s1 * 2 - 1;
        if (index < 2 * SCAN_BLOCKSIZE)
            scan_array[index] += scan_array[index - s1];
        GroupMemoryBarrierWithGroupSync();
    }

    // Downsweep
    for (uint s2 = SCAN_BLOCKSIZE >> 1; s2 > 0; s2 >>= 1) {
        uint index = (threadIdx + 1) * s2 * 2 - 1;
        if (index + s2 < 2 * SCAN_BLOCKSIZE)
            scan_array[index + s2] += scan_array[index];
        GroupMemoryBarrierWithGroupSync();
    }
    GroupMemoryBarrierWithGroupSync();

    // Write exclusive results (shift right by 1 within each block)
    if (t1 < len) {
        prefixSums[t1] = (threadIdx == 0) ? 0u : scan_array[threadIdx - 1];
    }
    if (t2 < len) {
        uint idx = threadIdx + SCAN_BLOCKSIZE - 1;
        prefixSums[t2] = scan_array[idx];
    }
    if (threadIdx == 0) {
        aux[blockIdx] = scan_array[2 * SCAN_BLOCKSIZE - 1];
    }
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixFixup(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint start = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint block_sum = aux2[blockIdx];

    if (start < len)                    prefixSums[start] += block_sum;
    if (start + SCAN_BLOCKSIZE < len)   prefixSums[start + SCAN_BLOCKSIZE] += block_sum;
}

[numthreads(512, 1, 1)]
void scatterUniques(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    if (indicators[i] == 1u) {
        uint dst = prefixSums[i];
        uniqueIndices[dst] = i;  // Write the index into sorted arrays, not the particle index
    }
}

[numthreads(512, 1, 1)]
void scatterActives(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= len) return;

    if (indicators[i] == 1u) {
        uint dst = prefixSums[i];
        activeIndices[dst] = i;  // Write the index into sorted arrays, not the particle index
    }
}

[numthreads(1, 1, 1)]
void writeUniqueCount(uint3 id : SV_DispatchThreadID)
{
    if (len == 0) { uniqueCount[0] = 0; return; }
    uint last = len - 1;
    uniqueCount[0] = prefixSums[last] + indicators[last];
}

[numthreads(1, 1, 1)]
void writeActiveCount(uint3 id : SV_DispatchThreadID)
{
    if (len == 0) { activeCount[0] = 0; return; }
    uint last = len - 1;
    activeCount[0] = prefixSums[last] + indicators[last];
}