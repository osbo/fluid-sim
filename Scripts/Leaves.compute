#pragma kernel markUniques
#pragma kernel prefixSum
#pragma kernel prefixFixup
#pragma kernel scatterUniques
#pragma kernel writeUniqueCount

#define SCAN_BLOCKSIZE 512

// Buffers
RWStructuredBuffer<uint> sortedMortonCodes;      // input: sorted morton codes
RWStructuredBuffer<uint> sortedIndices;          // input: sorted particle indices (same order as codes)
// nodeFlagsBuffer moved to Nodes.compute

RWStructuredBuffer<uint> uniqueIndicators;       // temp: e (0/1) whether entry is unique
RWStructuredBuffer<uint> prefixSums;             // temp: f (exclusive scan)
RWStructuredBuffer<uint> aux;                    // temp: per-block sums
RWStructuredBuffer<uint> aux2;                   // temp: scanned per-block sums

RWStructuredBuffer<uint> uniqueIndices;          // output: indices of first occurrence of each unique code (maps into particles)
RWStructuredBuffer<uint> uniqueCount;            // output: [0] = number of unique codes

uint count;                                      // total number of items

// groupshared for scan
groupshared uint scan_array[SCAN_BLOCKSIZE * 2];

[numthreads(512, 1, 1)]
void markUniques(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= count) return;

    uint isUnique = 0;
    if (i == 0) {
        isUnique = 1;
    } else {
        uint curr = sortedMortonCodes[i];
        uint prev = sortedMortonCodes[i - 1];
        isUnique = (curr != prev) ? 1u : 0u;
    }

    uniqueIndicators[i] = isUnique;

    // Note: node flag setting moved to Nodes.compute
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixSum(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint t1 = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint t2 = t1 + SCAN_BLOCKSIZE;

    // Load inputs
    scan_array[threadIdx] = (t1 < count) ? uniqueIndicators[t1] : 0u;
    scan_array[threadIdx + SCAN_BLOCKSIZE] = (t2 < count) ? uniqueIndicators[t2] : 0u;
    GroupMemoryBarrierWithGroupSync();

    // Upsweep
    for (uint s1 = 1; s1 <= SCAN_BLOCKSIZE; s1 <<= 1) {
        uint index = (threadIdx + 1) * s1 * 2 - 1;
        if (index < 2 * SCAN_BLOCKSIZE)
            scan_array[index] += scan_array[index - s1];
        GroupMemoryBarrierWithGroupSync();
    }

    // Downsweep
    for (uint s2 = SCAN_BLOCKSIZE >> 1; s2 > 0; s2 >>= 1) {
        uint index = (threadIdx + 1) * s2 * 2 - 1;
        if (index + s2 < 2 * SCAN_BLOCKSIZE)
            scan_array[index + s2] += scan_array[index];
        GroupMemoryBarrierWithGroupSync();
    }
    GroupMemoryBarrierWithGroupSync();

    // Write exclusive results (shift right by 1 within each block)
    if (t1 < count) {
        prefixSums[t1] = (threadIdx == 0) ? 0u : scan_array[threadIdx - 1];
    }
    if (t2 < count) {
        uint idx = threadIdx + SCAN_BLOCKSIZE - 1;
        prefixSums[t2] = scan_array[idx];
    }
    if (threadIdx == 0) {
        aux[blockIdx] = scan_array[2 * SCAN_BLOCKSIZE - 1];
    }
}

[numthreads(SCAN_BLOCKSIZE, 1, 1)]
void prefixFixup(uint3 Gid : SV_GroupID, uint3 Gtid : SV_GroupThreadID)
{
    uint threadIdx = Gtid.x;
    uint blockIdx = Gid.x;
    uint start = threadIdx + 2 * blockIdx * SCAN_BLOCKSIZE;
    uint block_sum = aux2[blockIdx];

    if (start < count)                    prefixSums[start] += block_sum;
    if (start + SCAN_BLOCKSIZE < count)   prefixSums[start + SCAN_BLOCKSIZE] += block_sum;
}

[numthreads(512, 1, 1)]
void scatterUniques(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= count) return;

    if (uniqueIndicators[i] == 1u) {
        uint dst = prefixSums[i];
        uniqueIndices[dst] = sortedIndices[i];
    }
}

[numthreads(1, 1, 1)]
void writeUniqueCount(uint3 id : SV_DispatchThreadID)
{
    if (count == 0) { uniqueCount[0] = 0; return; }
    uint last = count - 1;
    uniqueCount[0] = prefixSums[last] + uniqueIndicators[last];
}


